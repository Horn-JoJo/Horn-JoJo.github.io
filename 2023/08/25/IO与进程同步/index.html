<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>IO与进程同步 | kuroko's blog</title><meta name="author" content="Horn JoJo"><meta name="copyright" content="Horn JoJo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="C++条件变量面试高频指数：⭐⭐⭐⭐⭐ 条件变量（condition variable）:在C语言中我们使用pthread_cond_wait函数作为条件变量，它是由操作系统实现的条件变量，需要详细了解它的运行机制就可以了解C++中条件变量的实现。在C++11以后，我们可以使用条件变量(condition_variable)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件">
<meta property="og:type" content="article">
<meta property="og:title" content="IO与进程同步">
<meta property="og:url" content="http://kuroko.love/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="kuroko&#39;s blog">
<meta property="og:description" content="C++条件变量面试高频指数：⭐⭐⭐⭐⭐ 条件变量（condition variable）:在C语言中我们使用pthread_cond_wait函数作为条件变量，它是由操作系统实现的条件变量，需要详细了解它的运行机制就可以了解C++中条件变量的实现。在C++11以后，我们可以使用条件变量(condition_variable)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbed.kuroko.love/blog_background/%E4%B8%BB%E8%A7%92%E5%9B%A22.jpg">
<meta property="article:published_time" content="2023-08-25T13:16:10.000Z">
<meta property="article:modified_time" content="2023-09-02T15:08:25.000Z">
<meta property="article:author" content="Horn JoJo">
<meta property="article:tag" content="IO与进程同步">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed.kuroko.love/blog_background/%E4%B8%BB%E8%A7%92%E5%9B%A22.jpg"><link rel="shortcut icon" href="/asserts/kuroko.png"><link rel="canonical" href="http://kuroko.love/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'IO与进程同步',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-02 23:08:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/asserts/kuroko.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-HOME"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-HOME"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-tags"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao-"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlehe">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-film-full">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-TIFFANYSROOM_huaban"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-TIFFANYSROOM_huaban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-feijifenxianglianjie"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-feijifenxianglianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-xihuan"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xihuan"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picbed.kuroko.love/blog_background/%E4%B8%BB%E8%A7%92%E5%9B%A22.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="kuroko's blog"><span class="site-name">kuroko's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-HOME"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-HOME"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-tags"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tags"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao-"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlehe">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-film-full">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-TIFFANYSROOM_huaban"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-TIFFANYSROOM_huaban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-feijifenxianglianjie"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-feijifenxianglianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-xihuan"></i><svg class="menu_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xihuan"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IO与进程同步</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-25T13:16:10.000Z" title="发表于 2023-08-25 21:16:10">2023-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-02T15:08:25.000Z" title="更新于 2023-09-02 23:08:25">2023-09-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/">面试突破</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="IO与进程同步"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-条件变量"><a href="#C-条件变量" class="headerlink" title="C++条件变量"></a>C++条件变量</h1><h2 id="面试高频指数：⭐⭐⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐⭐</h2><ol>
<li><p>条件变量（<code>condition variable</code>）:<br>在<code>C</code>语言中我们使用<code>pthread_cond_wait</code>函数作为条件变量，它是由操作系统实现的条件变量，需要详细了解它的运行机制就可以了解<code>C++</code>中条件变量的实现。在<code>C++11</code>以后，我们可以使用条件变量(<code>condition_variable</code>)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。<code>C++</code>中包含的头文件<code>#include&lt;condition_variable&gt;</code>中。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两种动作：</p>
<ul>
<li>一个线程因等待条件变量的条件成立而挂起：</li>
<li>另外一个线程使<strong>条件成立</strong>从而给出线程的信号，从而唤醒被等待的线程；</li>
<li>为了防止竞争，条件变量的使用总是和一个互斥锁在一起；通常情况下这个锁是<code>std::mutex</code>, 并且管理这个锁只能是<code>std::unique_lock std::mutex</code>等<code>RAII</code>模板类，分别是使用以下两个方法实现：<ul>
<li>等待条件成立使用的<code>condition_variable</code>类成员<code>wait</code>或者<code>wait_for</code>或<code>wait_until</code>。</li>
<li>唤醒信号使用的是<code>condition_variable</code>类成员<code>notify_one</code>或者<code>notify_all</code>函数。<br><code>condition_variable</code>支持的函数如下：<ul>
<li>构造函数：它只有一个默认构造函数，拷贝构造函数和赋值符号重载均被禁止<code>condition_variable(const  condition_variable&amp;) = delete;</code>，<code>opterator= [delete]</code>;</li>
<li><code>wait</code>：<code>wait</code>目前支持<code>wait</code>，<code>wait_for</code>, <code>wait_until</code>等三种操作，分别对应不同的场景；</li>
</ul>
</li>
</ul>
</li>
<li><code>wait</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span></span></span><br></pre></td></tr></table></figure>
当前线程执行时就被阻塞，直到等到被<code>notify</code>唤醒，在阻塞线程的那一刻，该函数自动调用lck.unlock()，允许其他被<code>lck</code>锁定的线程继续运行。阻塞时被一旦某个线程<code>notify</code>时， 实际可能为虚假唤醒，该函数将解除阻塞并调用<code>lck.lock()</code>，获取互斥锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
调用时检查<code>pred</code>，如果<code>false</code>，则阻塞线程，并且调用<code>lock.unlock()</code>，否则，继续执行。阻塞时被一旦某个线程<code>notify</code>时，实际可能为虚假唤醒，该函数将再次检查<code>pred</code>，如果为<code>true</code>，则解除阻塞并调用<code>lck.lock()</code>，获取互斥锁；否则继续阻塞线程。</li>
<li><code>wait_for</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">        Predicate stop_waiting)</span></span>;</span><br></pre></td></tr></table></figure>
调用时，检查两个条件是否满足：<code>stop_waiting</code>返回是否<code>true</code>, 时间是否超时，如果两个条件都不满足，则阻塞线程，并调用<code>lock.unlock()</code>，否则，到达一定等待时间或满足条件被唤醒。注意等待超过时间段后自动唤醒，判断条件一般需要使用者自己在合适的时候判断，并通过<code>notify_one()</code>或<code>notify_all()</code>唤醒，所以在使用时应当通过判断返回值来检测是其由于超时返回还是正常唤醒，即状态是否为<code>std::cv_status::timeout</code>。程序示例如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex cv_m;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waits</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;<span class="comment">//使用std::unique_lock&lt;std::mutex 来管理std::mutex</span></span><br><span class="line">    <span class="keyword">if</span> (cv.<span class="built_in">wait_for</span>(lk, idx*<span class="number">100</span>ms, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; finished waiting. i == &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; timed out. i == &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">120</span>ms);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Notifying...\n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Notifying again...\n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waits, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(waits, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(waits, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(signals)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();<span class="comment">//t1 等待 100ms 后被唤醒，自动超时</span></span><br><span class="line">    t2.<span class="built_in">join</span>();<span class="comment">//t2 在120ms 处被唤醒，但condition未满足，再次进入阻塞，200ms 时由于超时返回</span></span><br><span class="line">    t3.<span class="built_in">join</span>();<span class="comment">//t3 在120ms 处被唤醒，但condition未满足，再次进入阻塞，220ms时被通知，正常返回。</span></span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread1 timed out. i == 0</span></span><br><span class="line"><span class="comment">Notifying...</span></span><br><span class="line"><span class="comment">Thread2 timed out. i == 0</span></span><br><span class="line"><span class="comment">Notifying again...</span></span><br><span class="line"><span class="comment">Thread3 finished waiting. i == 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><code>wait_until</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<code>wait_for</code>是通过<code>wait_until</code>实现的，到达指定截止时间或者满足条件<code>conditions</code>时线程即被唤醒。不同的是，到达时间是自动唤醒，而条件满足<code>conditions</code>时则是通过<code>notify_one()</code>或<code>notify_all()</code>唤醒，使用的时候要注意判断返回值，根据返回值确定该线程是被超时唤醒还是被其他线程<code>notify</code>正常唤醒，即状态是否为<code>std::cv_status::timeout</code>。</li>
<li><code>notify</code>:<pre><code>  - `notify_one` 唤醒一个阻塞的线程，唤醒线程的顺序可能是随机的，并没有特定的顺序。
  - `notify_one` 程序示例如下，我们可以看到每次唤醒的顺序并不是确定的;
</code></pre></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//condition_variable notify_one</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produce, consume;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cargo = <span class="number">0</span>;<span class="comment">//shared value producers and consumers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cargo == <span class="number">0</span>) consume.<span class="built_in">wait</span>(lck);</span><br><span class="line">    std::cout &lt;&lt; cargo &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cargo = <span class="number">0</span>;</span><br><span class="line">    produce.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cargo != <span class="number">0</span>) produce.<span class="built_in">wait</span>(lck);</span><br><span class="line">    cargo = id;</span><br><span class="line">    consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread consumers[<span class="number">10</span>], producers[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//spawn 10 consumes and 10 produces</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        consumers[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">        producers[i] = std::<span class="built_in">thread</span>(producer, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//join them back:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        producers[i].<span class="built_in">join</span>();</span><br><span class="line">        consumers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>notity_all</code>唤醒所有的线程在<code>condition_variable</code>下的线程。需要特别注意的是，可能唤醒所有阻塞的线程，但是唤醒的多个线程同一时间只能有一个线程可以持有<code>lck</code>锁，必须等待其执行<code>wait</code>之后的代码，并释放<code>lck</code>时，剩余的线程才可以运行，我们可以观察到以下程序示例，唤醒的程序都是随机的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable_any cv;</span><br><span class="line">std::mutex cv_m;</span><br><span class="line"><span class="comment">//This mutex is used for three purposes</span></span><br><span class="line"><span class="comment">//1) to synchronize accesses to i </span></span><br><span class="line"><span class="comment">//2) to synchronize accesses to std::cerr</span></span><br><span class="line"><span class="comment">//3) for the condition variable cv </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waits</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Waiting... \n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;thread:&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; ...finished waiting. i == 1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Notifying...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Notifying again...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waits, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(waits, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(waits, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(signals)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>虚假唤醒以及如何避免虚假唤醒：<br>当线程从等待已发出信号的条件变量中醒来，却发现它等待的条件未得到满足时，就会发生虚假唤醒，发生虚假唤醒通常是因为在发出条件变量信号和等待线程最终运行之间，另一个线程运行并更改了条件，导致<code>wait</code>的线程被唤醒后，实际条件却未满足。比如我们在<code>notify_all()</code>时多个线程都被唤醒，但此时实际共享区却只有少数几个线程可以操作，这时就会造成其他线程被虚假唤醒，可以在<code>wait</code>唤醒后再次进行检测<code>condition</code>解决虚假唤醒。</li>
</ol>
<ul>
<li>虚假唤醒导致的后果：之前要等待的某个条件实际上并没有符合，被唤醒的线程将可能会执行一系列非法操作。</li>
<li>通常的解决办法：在条件变量阻塞的代码处增加一个<code>while</code>循环，如果被唤醒就要检查一下条件是否符合，如果不符合则要再次进入阻塞等待。这样即避免了忙等待，又避免了虚假唤醒问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span> (something <span class="keyword">not</span> <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">condition_wait</span>(cond, mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">do</span> (something);</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="线程同步与异步"><a href="#线程同步与异步" class="headerlink" title="线程同步与异步"></a>线程同步与异步</h1><h2 id="面试高频指数：⭐⭐⭐⭐⭐-1"><a href="#面试高频指数：⭐⭐⭐⭐⭐-1" class="headerlink" title="面试高频指数：⭐⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐⭐</h2><p>线程同步操作：<br><code>C++</code>标准库提供了一下几种线程同步的方式：</p>
<ul>
<li>互斥量（支持超时加锁、递归加锁）；</li>
<li>读写锁（共享互斥量，也支持超时加锁）；</li>
<li>互斥量包装器(基于<code>RAII</code>的思想);</li>
<li>条件变量;</li>
<li>信号量（二元信号量、计数信号量）;</li>
<li><code>barrier</code>;</li>
<li><code>call_once</code>;</li>
</ul>
<p>不同的同步方式具有不同的使用场景和性能，实际使用时根据不同的场景选择不同的同步方式，分别就几种方式以上几种方式进行简要介绍：</p>
<ol>
<li><p>互斥量（<code>mutex</code>）:<br> 互斥量 （<code>mutex</code> ）是防止同时访问共享资源的程序对象，为避免线程更新共享变量时所出现问题，必须使用互斥量(<code>mutex</code>是<code>mutal exclusion</code>的缩写)来确保同时仅有一个线程可以访问某项共享资源。即使用互斥量来实现原子访问操作，防止多个线程对临界区同时操作而产生不一致的问题。<code>mutex</code>只有锁定（<code>locked</code>）和未锁定（<code>unlocked</code>）两种状态。任何时候，至多只有一个线程可以锁定互斥量。试图对已经锁定的互斥量再次加锁，将可能阻塞线程或者报错失败。<code>mutex</code>的底层可能封装的是操作系统<code>spinlock</code>，不同的操作系统不可能有不同的实现。<code>C++</code>中关于<code>mutex</code>的头文件为<code>#include &lt;mutex&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_block</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;std::cout&lt;&lt; c;&#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_block, <span class="number">50</span>, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span> <span class="params">(print_block, <span class="number">50</span>, <span class="string">&#x27;$&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">****************************************</span></span><br><span class="line"><span class="comment">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><code>C++</code>中还定义了<code>timed_mutex</code>： 在<code>mutex</code>的基础上增加了加锁的功能。<br><code>recursize_mutex</code>：在<code>mutex</code>的基础上增加了递归加锁的功能(此时，<code>lock()</code>函数可以在同一线程不释放锁的情况下多次调动)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享互斥量：<br><code>std::shared_mutex</code>是<code>C++17</code>标准引入的，由<code>unique_lock</code>和<code>shared_lock</code>两个模板类配合<code>shared_mutex</code>使用，主要用于读写共享锁。<code>unique_lock</code>用于写入是加锁。<code>shared_lock</code>用于读取时加锁，对线工在构造时自动对<code>shared_mutex</code>加锁，析构时自动对其解锁。头文件主要包含在<code>#include &lt;shared_mutex</code>。<code>shared_mutex</code>可用于保护数据不被多个线程同时访问。与其他便于独占访问的互斥锁类型相比，<code>shared_mutex</code>具有两种访问级别：</p>
</li>
</ol>
<ul>
<li><code>shared</code>：多个线程可以共享同一个互斥锁的所有权。</li>
<li><code>exclusive</code>：只有一个线程可以拥有互斥锁。<br>共享互斥锁通常用于多个读取操作可以同时访问同一资源而不会导致数据竞争，但只有一个写入操作的场景。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadSafeCounter</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多个线程同时读取counter计数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个线程可以修改counter计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个线程可以修改counter计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex mutex_;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadSafeCounter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment_and_print = [&amp;counter]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            counter.<span class="built_in">increment</span>();</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// Note: Writing to std::cout actually needs to be synchronized as well</span></span><br><span class="line">            <span class="comment">// by another std::mutex. This has been omitted to keep the example small.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">139677317637888 2</span></span><br><span class="line"><span class="comment">139677317637888 3</span></span><br><span class="line"><span class="comment">139677309245184 4</span></span><br><span class="line"><span class="comment">139677309245184 5</span></span><br><span class="line"><span class="comment">139677309245184 6</span></span><br><span class="line"><span class="comment">139677317637888 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
我们可以看到<code>increment</code>同时只能有一个线程对计数进行增加，但可能同时存在多个线程读取同一个计数。<code>shared_timed_mutex</code>是在<code>shared_mutex</code>的基础上增加了超时加锁功能。</li>
</ul>
<ol>
<li>互斥量包装器<br><code>lock_guard</code>：使用了<code>RAII</code>的机制对互斥量进行类模板封装，构造时加锁，析构时解锁。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mtx is automatically released when lock goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>互斥量包装器对比原生的<code>mutex</code>来说，创建即加锁，作用域结束后自动析构解锁，无需手动解锁。缺点是不能中途解锁，不支持赋值和移动。在需要加锁的地方，只需要任意实例化一个<code>lock_guard</code>，调用构造函数成功上锁，出作用域则<code>lock_guard</code>对象会被销毁，调用析构函数自动解锁从而不会造成死锁，但是提供的功能单一不够灵活。</p>
<p><code>unique_lock</code>：<code>unique_lock</code>类模板也是采用<code>RAII</code>的方式对锁进行了封装，并且也是以独占所有权的方式管理<code>mutex</code>对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造(或移动<code>move</code>赋值)时，<code>unique_lock</code>对象需要传递一个<code>mutex</code>对象作为他的参数，新创建的<code>unique_lock</code>对象负责传入的<code>mutex</code>对象的上锁和解锁操作。使用以上类型互斥量实例化<code>unique_lock</code>对象时，自动调用构造函数上锁，<code>unique_lock</code>对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题。与<code>lock_guard</code>不同的是，<code>unique_lock</code>更加的灵活，提供了更多的成员函数：</p>
<ul>
<li>上锁/解锁操作：<code>lock</code>、<code>try_lock</code>、<code>try_lock_for</code>、<code>try_lock_until</code>和<code>unlock</code>;</li>
<li>修改操作：支持移动赋值、交换（<code>swap</code>：与另一个<code>unique_lock</code>对象互换所管理的互斥量所有权）、释放（<code>release</code>：返回它所管理的互斥量对象的指针，并释放所有权。）</li>
<li>获取属性：<code>owns_lock</code>（返回当前对象是否上了锁）、<code>operator bool()</code>  (与<code>owns_lock()</code>)的功能相同)、<code>mutex</code>（返回当前<code>unique_lock</code>所管理的互斥量的指针）。</li>
</ul>
<ol>
<li>条件变量(<code>condition variable</code>)：<br>在<code>C++11</code>以后，我们可以使用条件变量（<code>condition_variable</code>）实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。<code>C++</code>中包含的头文件在<code>#include &lt;condition_variable</code>中。<br>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</li>
</ol>
<ul>
<li>一个线程因等待<code>条件变量的条件成立</code>而挂起：</li>
<li>另外一个线程使<code>条件成立</code>从而给出唤醒线程的信号，从而唤醒被等到的线程；<br>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是<code>std::mutex</code>，并且管理这个锁只能是<code>std::unique_lock std::mutex</code>等RAII模板类。分别是使用以下两个方法实现：</li>
<li>等待条件成立使用的是<code>condition_variable</code>类成员<code>wait</code>、<code>wait_for</code>或<code>wait_until</code>。</li>
<li>唤醒信号使用的是<code>condition_variable</code>类成员<code>notify_one</code>或者<code>notify_all</code>函数。<br>我们可以看到<code>wait</code>函数如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;Class Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate stop_waiting)</span></span>;</span><br></pre></td></tr></table></figure>
线程会一直挂起，直到<code>stop_waiting</code>为<code>true</code>为止。程序示例如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::string data;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// worker 线程等待 ready</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> ready;&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 唤醒执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing data\n&quot;</span>;</span><br><span class="line">    data += <span class="string">&quot; after processing&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// processed 设置为 true, 唤醒 main 线程</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread signals data processing completed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放锁，防止再次被唤醒。</span></span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">// 唤醒 main 线程</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line">    <span class="comment">// 让 worker 线程先执行，再进行唤醒，否则可能出现 ready = true 先于 worker 线程的执行</span></span><br><span class="line">    worker.<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    data = <span class="string">&quot;Example data&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置 ready 为 true, 唤醒 worker 线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main() signals data ready for processing\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 worker 线程</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="comment">// 等待 worker 线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> processed;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back in main(), data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main() signals data ready for processing</span></span><br><span class="line"><span class="comment">worker thread signals is processing data</span></span><br><span class="line"><span class="comment">.Worker thread signals data processing completed</span></span><br><span class="line"><span class="comment">Back in main(), data = Example data after processing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>信号量<br><code>C++20</code>中添加了<code>C++</code>中的信号量为二元信号量与计数信号量，二元信号量实际为计数信号量模板的特化。</li>
</ol>
<ul>
<li><code>binary_semphore</code>：二元信号量类似于互斥量，信号量只要0和1。</li>
<li><code>counting_semphore</code>：计数信号量<br>所有关于信号量的定义参考头文件<code>#include &lt;semaphore&gt;</code>, 计数信号量是一种轻量级同步原语，可以控制对共享资源的访问。与<code>std::mutex</code>不同的是，<code>counting_semphore</code>至少允许<code>LeastMaxValue</code>并发访问者对同一资源进行多个访问。<code>counting_semphore</code>包含一个由构造函数初始化的内部计数器。该计数器可以通过<code>acquire</code>获取资源访问权限，并ton过调用<code>release()</code>来释放资源从而递增计数器。当计数器为零时，调用<code>acquire()</code>时就会阻塞直到计数器增加，但是调用<code>try_acquire()</code>不阻塞;<code>try_acquire_for()</code>和<code>try_acquire_until()</code>阻塞直到计数器增加或达到超时。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::binary_semaphore</span><br><span class="line">	smphSignalMainToThread&#123;<span class="number">0</span>&#125;,</span><br><span class="line">	smphSignalThreadToMain&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">// 第一次进入阻塞</span></span><br><span class="line">	smphSignalMainToThread.<span class="built_in">acquire</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;[thread] Got the signal\n&quot;</span>; <span class="comment">// response message</span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;[thread] Send the signal\n&quot;</span>; <span class="comment">// message</span></span><br><span class="line">    <span class="comment">// 唤醒 main 线程</span></span><br><span class="line">	smphSignalThreadToMain.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thrWorker</span><span class="params">(ThreadProc)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;[main] Send the signal\n&quot;</span>; <span class="comment">// message</span></span><br><span class="line">    <span class="comment">// 唤醒 ThreadProc </span></span><br><span class="line">	smphSignalMainToThread.<span class="built_in">release</span>();</span><br><span class="line">    <span class="comment">// main 线程阻塞</span></span><br><span class="line">	smphSignalThreadToMain.<span class="built_in">acquire</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;[main] Got the signal\n&quot;</span>; <span class="comment">// response message</span></span><br><span class="line">	thrWorker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[main] Send the signal</span></span><br><span class="line"><span class="comment">[thread] Got the signal</span></span><br><span class="line"><span class="comment">[thread] Send the signal</span></span><br><span class="line"><span class="comment">[main] Got the signal</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><code>barrier</code>：<br><code>C++ 20</code>以后支持<code>latch</code>与<code>barrier</code>，他们同样是用来线程同步。</li>
</ol>
<p><code>latch</code>：类<code>latch</code>是<code>std::pridiff_t</code>类型的向下计数器，可用来同步线程。计数器的值在创建时初始化。其内部维护者一个计数器，当计数器不为0时，所有参与者(线程)都将阻塞在等待操作处，计数为<code>0</code>时，解除阻塞。计数器不可重置或增加，故它是一次性的，不可重用。与<code>std::barrier</code>不同，<code>std::latch</code>参与线程可以多次递减。</p>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//latch是一种倒计时的计数器，它的值在构造函数中设置，线程中可以使用</span></span><br><span class="line">    <span class="comment">//初始值为2</span></span><br><span class="line">    <span class="function">std::latch <span class="title">work_done</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    work_done.<span class="built_in">count_down</span>();<span class="comment">//以非阻塞的方式对计数器进行减1操作 接着继续往下执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//work_done.wait();//当计数值不为0时，就一直阻塞，直到为0才不阻塞（不会减1操作）</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;waiting because the counter is nozero&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">bool</span> ok = work_done.<span class="built_in">try_wait</span>();<span class="comment">//测试内部的计数值是否为0 如果为0则返回true 否则返回false 这时还是1 </span></span><br><span class="line">    std::cout &lt;&lt; ok &lt;&lt; std::endl;<span class="comment">//ok = 0</span></span><br><span class="line">    work_done.<span class="built_in">arrive_and_wait</span>();<span class="comment">//递减计数器并阻塞直到它到达0(这里会减1) 这里减1操作后变成0，就不会阻塞了！继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;倒计时结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">倒计时结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>barrier</code>：类似于<code>latch</code>，<strong>它会阻塞线程直到所有参与者线程都达到一个同步点，直到预期数量的线程到达设定的值则会解除阻塞</strong>。与<code>latch</code>不同的是，<strong>它是可重用的</strong>。<br>一个<code>barrier</code>的声明周期包含多个阶段，每个阶段都定义了一个同步点。一个<code>barrier</code>阶段包含：</p>
<ul>
<li>期望计数(设创建时指定的计数为<code>n</code>)，当期望计数不为<code>0</code>时，参数者将阻塞与等待操作处</li>
<li>当期望计数为<code>0</code>时，会执行创建<code>barrier</code>时指定的阶段完成步骤，然后解除阻塞所有阻塞于同步点的参与者线程。</li>
<li><p>当阶段完成步骤执行完成后，会重置期望计数为<code>n-调用arrive_and_drop()</code>的次数，然后开始下一个阶段</p>
<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认是初始化列表: initializer_list</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> workers = &#123;<span class="string">&quot;anil&quot;</span>, <span class="string">&quot;busara&quot;</span>, <span class="string">&quot;carl&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; typeid(workers).name() &lt;&lt; endl;//St16initializer_listIPKcE</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> on_completion = []() <span class="keyword">noexcept</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lamda函数 [] 里可接收外部参数 () 里是形参列表，可以自定义参数</span></span><br><span class="line"><span class="comment">    等价于noexcept(true) 注意: 这里括号中可以填写表达式, 值为true 则不会抛出异常，否则会抛出异常</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">auto</span> phase = <span class="string">&quot;...done\n&quot;</span><span class="string">&quot;Cleaning up...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; phase;</span><br><span class="line">        phase = <span class="string">&quot;...done\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ssize(workers): 求初始化列表中的元素个数！</span></span><br><span class="line">    <span class="comment">//barrier对象初始为3个线程同步点！</span></span><br><span class="line">    <span class="function">std::barrier <span class="title">sync_point</span><span class="params">(std::ssize(workers), on_completion)</span></span>;<span class="comment">//当ssize(workers)个线程每完成一个阶段的任务，就会执行一次on_completion函数！！！</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> work = [&amp;](std::string name) &#123;</span><br><span class="line">        std::string product = <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; worked\n&quot;</span>;<span class="comment">// anill workded</span></span><br><span class="line">        std::cout &lt;&lt; product;<span class="comment">//ok, op &lt;&lt; call is atomic</span></span><br><span class="line">        <span class="comment">//当 std::arrive_and_wait 在同步点等待时，std::arrive_and_drop 将自己从同步机制中删除</span></span><br><span class="line">        sync_point.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部到达后，进行下一阶段 此时内部计数会减少1</span></span><br><span class="line">        product = <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;cleaned\n&quot;</span>;<span class="comment">// anill cleaned</span></span><br><span class="line">        std::cout &lt;&lt; product;</span><br><span class="line">        sync_point.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Starting...\n&quot;</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;<span class="comment">//线程对象数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; worker : workers) &#123;<span class="comment">//遍历初始化列表，然后创建线程并传入参数</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(work, worker);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//每个1s实例化线程对象 当线程数小于3时，每个线程会卡在第一阶段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;<span class="comment">//让主线程等待子线程结束然后回收资源</span></span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Starting...</span></span><br><span class="line"><span class="comment">这里是3个线程均执行第一阶段的任务</span></span><br><span class="line"><span class="comment"> anil worked</span></span><br><span class="line"><span class="comment"> busara worked</span></span><br><span class="line"><span class="comment"> carl worked</span></span><br><span class="line"><span class="comment">3个线程第一阶段的任务都执行完了，此时打印on_completion函数的内容</span></span><br><span class="line"><span class="comment">...done</span></span><br><span class="line"><span class="comment">Cleaning up...</span></span><br><span class="line"><span class="comment">此时内部计数会减少1。然后只需要两个线程执行就可以印on_completion了！！！</span></span><br><span class="line"><span class="comment">然后这三个线程开始执行第二阶段的任务</span></span><br><span class="line"><span class="comment"> busaracleaned</span></span><br><span class="line"><span class="comment"> carlcleaned</span></span><br><span class="line"><span class="comment"> anilcleaned</span></span><br><span class="line"><span class="comment"> 第二段任务结束后，再次打印on_completion函数的内容，因为内部是静态字符串，第二次不再执行初始化操作</span></span><br><span class="line"><span class="comment"> 直接打印第一次修改后的字符串值</span></span><br><span class="line"><span class="comment">...done</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><code>call_once</code><br><code>C++11</code>以后支持<code>call_once</code>。确保某个操作只被执行一次(成功执行才算), 即使是多线程环境下也确保只执行一次。<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Callable</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
如果在<code>call_once</code>被调用时，<code>flag</code>表明<code>f</code>已经被调用，则<code>call_once</code>立即返回(这种调用<code>call_once</code>称为被动)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class Callable, class... Args&gt;</span></span><br><span class="line"><span class="comment">void call_once(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args);</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is running simple_do_once&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//这个</span></span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []() &#123; std::cout &lt;&lt; <span class="string">&quot;simple example: called once\n&quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hhhhhh &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的线程都会执行simple_do_once的函数，只是call_once这个只会被某一个线程函数执行一次！！！其他线程函数就会忽略掉这一行！！！！</span></span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h1 id="多线程异步"><a href="#多线程异步" class="headerlink" title="多线程异步"></a>多线程异步</h1><h2 id="面试高频指数：⭐⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐</h2><hr>
<ol>
<li><p><code>std::thread</code></p>
<p>我们可以通过<code>thread</code>创建一个线程(<code>C++11</code>以后才支持<code>thread</code>标准库)，<code>thread</code>在构造相关线程对象完成后立即开始执行(<strong>实际需要等待<code>OS</code>对于线程的调用延迟</strong>)。<code>thread</code>需要配合与<code>join</code>或者<code>detach</code>配合使用，不然可能出现不可预料的后果。</p>
<ul>
<li><code>join</code> 代表阻塞当前主线程，等待当前的<code>join</code>的子线程完成后主线程才会继续</li>
<li><code>detach</code>表明当前子线程不阻塞主线程，且与主线程分离，子线程的运行不会影响到主线程。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span> <span class="params">(string st2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; st2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span> <span class="params">(string st1)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; st1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thr1</span><span class="params">(fn1, <span class="string">&quot;11111111\n&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thr2</span><span class="params">(fn2, <span class="string">&quot;22222222\n&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//thr1.join();</span></span><br><span class="line">    <span class="comment">//thr2.join();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">当没有join或者detach时，会报如下错误</span></span><br><span class="line"><span class="comment">terminate called without an active exception</span></span><br><span class="line"><span class="comment">11111111</span></span><br><span class="line"><span class="comment">Aborted</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">否则正常打印</span></span><br><span class="line"><span class="comment">11111111</span></span><br><span class="line"><span class="comment">22222222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如<strong>在一个类中间，一个成员函数需要<code>异步调用</code>另一个函数的时候，需要绑定<code>this</code></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> std::string s1, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="comment">//类中的该成员函数调用另一个成员函数，绑定了this!!!</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;Test::func1, <span class="keyword">this</span>, <span class="string">&quot;dog&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        t1.<span class="built_in">join</span>();<span class="comment">//这里为join时，就会先去执行func1，执行完后再去执行fun2后续逻辑。那么结果始终是dog 0\n func2</span></span><br><span class="line">        <span class="comment">//t1.detach(); 当这里为detach打印的结果是不可预知的！！！因为fun2执行完了，这里t1对象已经被销毁了，可能执行fun1时会出现问题！！！</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test a;</span><br><span class="line">    a.<span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::async</code></p>
</li>
</ol>
<blockquote>
<p>我们进行异步编程时，需要得到子进程的计算结果，常见的手段是我们可以通过<strong>共享变量或者消息队列</strong>的方式告知另一个线程当前的计算结果，但是操作和实现都比较麻烦，同时还要考虑线程间的互斥问题。<code>C++11</code>中提供了一个相对简单的异步接口<code>std::async</code>，通过这个接口可以简单地创建线程并通过<code>std::future</code>中获取结果，极大的方便了<code>C++</code>多线程编程。<strong><code>std::async</code>适合于需要取得结果的异步线程</strong>。<code>C++11</code>中的<code>std::async</code>是个模板函数。<code>std::async</code>异步调用函数，<strong>在某个时候以<code>Args</code>作为参数(可变长参数)调用函数，无需等待函数执行完成就可返回，返回结果是个<code>std::future</code>对象。函数返回的值可通过<code>std::future</code>对象的<code>get</code>成员函数获取。一旦完成函数的执行，共享状态将包含函数返回的值并<code>ready</code>。</strong></p>
</blockquote>
<p>​        <code>async</code>使用的函数原型和参数说明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(C++11 起)（C++17 前）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Functon</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>(Function&amp;&amp; f, Args&amp;&amp;... args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>(std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一个参数是<code>std::async</code>的启动策略类型有以下两种方式：<code>async</code>允许调用者选择特定的启动策略：</p>
<ul>
<li><p><code>std::launch::async</code>：</p>
<blockquote>
<p><strong>在调用<code>async</code>就开始创建线程</strong>，该函数由线程异步调用，并且将其返回值与共享状态的访问点同步。</p>
</blockquote>
</li>
<li><p><code>std::launch::deferred</code>：</p>
<blockquote>
<p><strong>延迟启动线程，在访问共享状态时该线程才启动</strong>。<strong>对函数的调用将推迟到返回的<code>std::future</code>的共享状态被访问时</strong>（即使用<code>std::future</code>的<code>wait</code>或<code>get</code>函数）。如果<code>get</code>或<code>wait</code>没有被调用，函数就绝对不会执行。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>参数<code>Function</code></p>
<blockquote>
<p>可以为函数指针、成员指针、任何类型的可移动构造的函数对象，也可以匿名函数<code>lambda</code>。<strong><code>Function</code>的返回值或异常存储在共享状态以供异步的<code>std::future</code>对象检索</strong>。<strong><code>std::future</code>对象可以通过<code>wait</code>或<code>get</code>函数获取函数的返回值。</strong></p>
</blockquote>
</li>
</ul>
<ul>
<li><p>参数<code>Args</code></p>
<blockquote>
<p>传递给函数<code>Function</code>调用的参数，它们的类型应是可移动构造的。我们可以用多线程程序分为子任务，用子任务求解。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个任务分成若干个小任务去执行，每个小任务用新的线程来处理！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallel_sum</span><span class="params">(RandomIt beg, RandomIt end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(beg, end, <span class="number">0</span>);<span class="comment">//当规模小于1000时，就去累加该区间的部分和</span></span><br><span class="line"></span><br><span class="line">    RandomIt mid = beg + len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                             parallel_sum&lt;RandomIt&gt;, mid, end);<span class="comment">//当规模大于1000时，则划分一半开启一个新的线程来处理，如果还是大于1000，则新线程又会创建新的线程来处理</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">parallel_sum</span>(beg, mid);<span class="comment">//计算开始到中间的一半规模的求和。如果规模还是很大，还会创建新的线程来计算较小的和！！！</span></span><br><span class="line">    <span class="keyword">return</span> sum + handle.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上代码逻辑！！！ 递归+多线程！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallel_min</span><span class="params">(RandomIt beg, RandomIt end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> *(std::<span class="built_in">min_element</span>(beg, end));</span><br><span class="line"></span><br><span class="line">    RandomIt mid = beg + len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                             parallel_min&lt;RandomIt&gt;, mid, end);</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">parallel_min</span>(beg, mid);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(ans, handle.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; <span class="built_in">parallel_sum</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The min elemnet is &quot;</span> &lt;&lt; <span class="built_in">parallel_min</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p><code>std::future</code></p>
<p><strong>通常与<code>std::promise</code>一起使用</strong>：作用是在一个<strong>线程<code>t1</code>中保存一个类型<code>Typename T</code>的值</strong>，<strong>可供相绑定的<code>std::future</code>对象在另一个线程<code>t2</code>中获取</strong></p>
<blockquote>
<p><code>std::future</code>提供了一种访问线程异步操作结果的机器。从字面意思来看，<code>future</code>表示未来，<code>std::async</code>返回结果即为一个<code>future</code>。在实际工程项目中，一个异步操作我们是不可能马上就获取操作结果的，只能是在未来的某个时候获取，但是我们可以同步等待的方式来获取结果，可以通过查询<code>future</code>的状态(<code>future_status</code>)来获取异步操作的结果。<code>future_status</code>有三种状态：</p>
</blockquote>
<ul>
<li><p><code>deferred</code>： 异步操作还没开始</p>
</li>
<li><p><code>ready</code>：异步操作已经完成</p>
</li>
<li><p><code>timeout</code>：异常操作超时</p>
<blockquote>
<p>获取<code>future</code>结果有三种方式：<code>get</code>、<code>wait</code>、<code>wait_for</code>，其中</p>
<p><strong><code>get</code>等待异步操作结束并返回结果</strong></p>
<p><strong><code>wait</code>只是等待异步操作完成，没有返回值</strong></p>
<p><strong><code>wait_for</code>是超时等待返回结果</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//future from async </span></span><br><span class="line">    <span class="comment">//使用std::async创建匿名函数的线程函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, [] &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//future from a promise</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;<span class="comment">//确定要在一个线程中设置的值类型为int类型 这个用于传入一个线程，并且在线程里设置值</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f2 = p.<span class="built_in">get_future</span>();<span class="comment">//将future对象绑定！！！</span></span><br><span class="line">    <span class="comment">//这个用于另外一个线程，用于获取与该对应绑定的int类型值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个将p传入匿名函数创建的线程中，并设置值为9</span></span><br><span class="line">    std::<span class="built_in">thread</span>([&amp;p] &#123; p.<span class="built_in">set_value_at_thread_exit</span>(<span class="number">9</span>); &#125;).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting...&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">    <span class="comment">//等待f1和f2两个异步线程执行完</span></span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="comment">//分别打印每个异步线程返回的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Done!\nResults are: &quot;</span> &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 **std::future与std::promise**

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&amp;)&gt;;</span><br><span class="line"><span class="comment">//typedef std::function&lt;int(int, int, int&amp;) T;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread fun1 is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; f)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread fun2 is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waitting for f.get()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//这里会先被执行到，接下来会阻塞在get这里</span></span><br><span class="line">    <span class="comment">//因为fun1在5s过后才会设置值，因此这里会等待！！！</span></span><br><span class="line">    <span class="keyword">auto</span> v = f.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f.get() = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;<span class="comment">//定义一个用来保存int的变量</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();<span class="comment">//绑定p和f p.set_value() =&gt; f.get()</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(fun1, std::ref(p))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(fun2, std::ref(f))</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//主线程等待子线程运行完才继续执行主线程逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread fun1 is running...</span></span><br><span class="line"><span class="comment">thread fun2 is running...</span></span><br><span class="line"><span class="comment">waitting for f.get()</span></span><br><span class="line"><span class="comment">f.get() = 999</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</code></pre><h1 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h1><h2 id="面试高频指数：⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐"></a>面试高频指数：⭐⭐⭐</h2><hr>
<p><code>C++</code>保持与<code>C</code>兼容，因此也保留支持<code>printf</code>和<code>scanf</code>进行输出和输入的方法。<code>C++</code>具有面向对象的特性，引入了新的输入输出。<code>C++</code>通过<code>I/O</code>类库来实现丰富的<code>I/O</code>功能。在<code>C++</code>中，输入和输出以字节序列或更通常称为<code>stream</code>的形式执行。</p>
<ul>
<li>输入流（<code>inputstream</code>）：如果字节流的方向是从设备(例如键盘)到主存，那么这个过程称为输入。</li>
<li>输出流（<code>outputstream</code>）：如果字节流的方向相反，即从主存到设备(显示屏)，那么这个过程称为输出。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Horn-JoJo/pic_bed@main/2023/071661515629-ypuTEg-6_1_1.png" alt=""></p>
<p><code>C++</code>采用了面向对象的思想对所有涉及<code>I/O</code>的操作进行了统一的封装，涉及到<code>I/O</code>操作的主要由<code>&lt;iostream&gt;, &lt;iomanip&gt;, &lt;fstream&gt;</code>三个头文件组成，<code>stream</code>是其行为由类定义的对象，其中主要的类的继承关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Horn-JoJo/pic_bed@main/2023/071661515645-WNnqbw-6_1_2.png" alt=""></p>
<p><code>C++</code>中的<code>Streams</code>对象主要分为三种类型：</p>
<ul>
<li><code>istream</code>：这种类型的流对象只能从流中执行输入操作</li>
<li><code>ostream</code>：这种对象只能用于输出操作</li>
<li><code>iostream</code>：可用于输入和输出操作</li>
</ul>
<ol>
<li><p>标准输入输出</p>
<ul>
<li>标准输出流(<code>cout</code>)：通常标准输出设备是显示器。<code>C++ cout</code>语句是<code>ostream</code>类的实例。它用于在标准输出设备上产生输出。需要在屏幕上显示的数据使用插入运算符(<code>&lt;&lt;</code>)插入到标准输出流(<code>cout</code>)中。</li>
<li>标准输入流(<code>cin</code>)：通常计算机中的输入设备是键盘。<code>C++ cin</code>语句是<code>istream</code>类的实例，用于从标准输入设备(通常是键盘)读取输入。提取运算符(<code>&gt;&gt;</code>)与对象<code>cin</code>一起用于读取输入。提取运算符从使用键盘输入的对象<code>cin</code>中提取数据。</li>
</ul>
</li>
<li><p><code>I/O</code>重定向</p>
<ul>
<li><p>获取<code>A</code>的流缓冲区并将其存储在某处</p>
</li>
<li><p>将<code>A</code>的流缓冲区设置为<code>B</code>的流缓冲区</p>
</li>
<li><p>如果需要将<code>A</code>的流缓冲区重置为其先前流缓冲区</p>
<p>我们可以使用函数<code>ios::rdbuf()</code>来执行一下两个操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream_object.<span class="built_in">rdbuf</span>();<span class="comment">//获取返回指向stream_object的流缓冲区的指针</span></span><br><span class="line">stream_object.<span class="built_in">rdbuf</span>(streambuf *p);<span class="comment">//将流缓冲区设置为p指向的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以下为程序示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;cout.txt&quot;</span>, ios::out);</span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存cin和cout的缓冲区buffer</span></span><br><span class="line">    streambuf* stream_buf_cout = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    streambuf* stream_buf_cin = cin.<span class="built_in">rdbuf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件file的缓冲区buffer </span></span><br><span class="line">    streambuf* stream_buf_file = file.<span class="built_in">rdbuf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout 重定向输出到文件file</span></span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(stream_buf_file);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The cout is redirected to file&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复重定</span></span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(stream_buf_cout);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>C/C++</code>如何清除输入缓冲区</p>
<blockquote>
<p>所有标准输入和标准输出都包含一个输入和输入缓冲区。在标准<code>C/C++</code>中，流被缓冲，例如在标准输入的情况下，当我们按下键盘上的键时，它不会发送到您的程序，而是由操作系统发送到缓冲区，直到进程调度时才会将其分配该程序(理解输了很多次，过了一段时间后才显示)。</p>
<p>在各种情况下，可能需要清除不需要的缓冲区，以便在所需的程序中立即获取下一个输入，而不是在前一个变量的缓冲区中。比如<code>C</code>遇到<code>scanf()</code>后，需要输入字符数组或字符，<code>C++</code>遇到<code>cin</code>语句后，需要输入字符数组或字符。当我们从键盘获取一个字符串时，我们需要清除输入缓冲区，否则所需的输入被前一个变量的缓冲区占用。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch,<span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码没有正确打印出字符串<code>ch</code>的值，原因是缓冲区被占用。<code>\n</code>字符保留在缓冲区中，并作为下一个输入读取，因此我们在需要在输入<code>ch</code>之前，将缓冲区进行清除。</p>
<ul>
<li>使用<code>cin.ignore</code>：</li>
<li>使用<code>cin.ignore(numeric_limits::max(), &#39;\n&#39;)</code>，在<code>cin</code>语句之后丢弃输入流中的所有内容，包括换行符。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用<code>cin&gt;&gt;ws</code>：</p>
<p>在<code>cin</code>语句之后输入<code>cin&gt;&gt;ws</code>告诉编译器忽略缓冲区丢弃字符串或字符数组实际内容之前的所有空格。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; ws;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>IO与进程同步</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://kuroko.love/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">http://kuroko.love/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Horn JoJo</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-08-25</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-09-02</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="LOVE BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">LOVE BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/">IO与进程同步</a></div><div class="post_share"><div class="social-share" data-image="https://picbed.kuroko.love/blog_background/%E4%B8%BB%E8%A7%92%E5%9B%A22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/19/GDB%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/" title="GDB常见使用命令"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.kuroko.love/blog_background/%E5%BE%A1%E5%9D%82%E7%BE%8E%E7%90%B4and%E7%99%BD%E4%BA%95%E9%BB%91%E5%AD%90.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GDB常见使用命令</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/24/linux/" title="linux系统背景&amp;系统架设"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.kuroko.love/blog_background/%E9%A3%9F%E8%9C%82%E6%93%8D%E7%A5%882.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux系统背景&amp;系统架设</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/asserts/kuroko.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Horn JoJo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://Horn-JoJo.github.io"><i class="fab fa-github"></i><span>kuroko的小家</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Horn-JoJo/" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-Gitshezhi"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://leetcode.cn/u/jann_horn/" target="_blank" title="Leetcode"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-leetcode"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://b23.tv/aqCcTQk" target="_blank" title="Blibili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://res.abeim.cn/api/qq/?qq=1494484196" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:1494484196@qq.com" target="_blank" title="邮件"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youjian"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:5px" aria-hidden="true"><use xlink:href="#icon-gonggao"></use></svg></a><span>公告栏</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">C++条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-text">面试高频指数：⭐⭐⭐⭐⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">线程同步与异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90-1"><span class="toc-text">面试高频指数：⭐⭐⭐⭐⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5"><span class="toc-text">多线程异步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%AD%90%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-text">面试高频指数：⭐⭐⭐⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%93%8D%E4%BD%9C"><span class="toc-text">IO操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-text">面试高频指数：⭐⭐⭐</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Horn JoJo</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="//at.alicdn.com/t/c/font_4183657_j03j2wub0ye.js"></script><script src="https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js"></script><script defer src="/js/toggleImage.js"></script><script defer src="/js/life.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://kuroko.love/categories/C/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 C++学习 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://kuroko.love/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.3.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/08/16/目标清单/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbed.kuroko.love/blog_background/%E4%B8%BB%E8%A7%92%E5%9B%A22.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-16</span><a class="blog-slider__title" href="2023/08/16/目标清单/" alt="">成长日记</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/08/16/目标清单/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__bounceInDown');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('pagination');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__lightSpeedInRight');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.kuroko.love/api?Horn-JoJo",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'Horn-JoJo')
    }
  </script><!-- hexo injector body_end end --></body></html>