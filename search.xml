<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣语法大杂烩</title>
      <link href="/2023/10/19/%E5%8A%9B%E6%89%A3%E8%AF%AD%E6%B3%95%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2023/10/19/%E5%8A%9B%E6%89%A3%E8%AF%AD%E6%B3%95%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p><strong>Rust</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">const</span> M：<span class="type">i32</span> = <span class="number">1_000_000_000</span>;` : **不能用元组包起来**</span><br></pre></td></tr></table></figure><p><strong>Python3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = 10**9 # M大写就表示是常量</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A, b, c = <span class="string">&quot;hhhh&quot;</span>, <span class="number">123</span>, <span class="number">15.0009</span> <span class="comment">//这里用const修饰，可以连续赋值！</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><strong>Rust</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>(); <span class="comment">//将字符数组转成字符串</span></span><br><span class="line"><span class="title function_ invoke__">for</span> (_, &amp;x) <span class="keyword">in</span> s.<span class="title function_ invoke__">as_bytes</span>().<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()<span class="comment">//将字符串s转成字节数组进行遍历</span></span><br></pre></td></tr></table></figure><p><strong>Python3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M = 10**9 # M大写就表示是常量</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> A, b, c = <span class="string">&quot;hhhh&quot;</span>, <span class="number">123</span>, <span class="number">15.0009</span> <span class="comment">//这里用const修饰，可以连续赋值！</span></span><br></pre></td></tr></table></figure><h1 id="swich"><a href="#swich" class="headerlink" title="swich"></a>swich</h1><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量 var1 可以是任何类型，而 <strong>val1 和 val2 则可以是同类型的任意值</strong>。<strong>类型不被局限于常量或整数，但必须是相同的类型</strong>；<strong>或者最终结果为相同类型的表达式</strong>。</p></blockquote><h1 id="累加求和与统计个数"><a href="#累加求和与统计个数" class="headerlink" title="累加求和与统计个数"></a>累加求和与统计个数</h1><p><strong>Python3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.count(&#x27;*&#x27;) for t in s.split(&#x27;|&#x27;)[::2]//将s用| 进行分割然后统计\*的个数构成列表，然后奇数个进行访问</span><br><span class="line">sum(t.count(&#x27;*&#x27;) for t in s.split(&#x27;|&#x27;)[::2])//奇数个位置的元素进行累加求和</span><br></pre></td></tr></table></figure><p><strong>Go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp := strings.Split(s, <span class="string">&quot;*&quot;</span>)<span class="comment">//将s用&quot;*&quot;分割成数组放到sp中</span></span><br><span class="line">strings.Count(sp[i], <span class="string">&quot;*&quot;</span>)<span class="comment">//将sp[i]中&quot;*&quot;统计出来</span></span><br></pre></td></tr></table></figure><h1 id="Rust特殊语法"><a href="#Rust特殊语法" class="headerlink" title="Rust特殊语法"></a>Rust特殊语法</h1><h2 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="string">&quot;12345 world!&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(num) = x[<span class="number">0</span>..<span class="number">6</span>].parse::&lt;<span class="type">i32</span>&gt;() &#123;<span class="comment">//切片0..5的数字将其转换为i32类型，如果能够转换成功，则赋值为OK(num)中</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">60</span> &#123;</span><br><span class="line">        ans += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="iter、filter-map、filiter、count、map"><a href="#iter、filter-map、filiter、count、map" class="headerlink" title="iter、filter_map、filiter、count、map"></a>iter、filter_map、filiter、count、map</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">details.</span><br><span class="line">    <span class="title function_ invoke__">iter</span>().</span><br><span class="line">    <span class="title function_ invoke__">filter_map</span>(|s| s[<span class="number">11</span>..<span class="number">13</span>].parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">ok</span>()).</span><br><span class="line">    <span class="title function_ invoke__">filter</span>(|&amp;age| age &gt; <span class="number">60</span>).</span><br><span class="line">    <span class="title function_ invoke__">count</span>() <span class="keyword">as</span> <span class="type">i32</span></span><br><span class="line"></span><br><span class="line">h.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|&amp;x| x <span class="keyword">as</span> <span class="type">i64</span>).<span class="title function_ invoke__">sum</span>()<span class="comment">//对将h的每个元素转化为i64类型然后求和并返回</span></span><br></pre></td></tr></table></figure><h2 id="字节数组转字符串"><a href="#字节数组转字符串" class="headerlink" title="字节数组转字符串"></a>字节数组转字符串</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span>::<span class="title function_ invoke__">from_utf8_lossy</span>(&amp;bytes);<span class="comment">//将字节数组转化成字符串</span></span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heapify(nums) # 原地堆化 默认是小根堆，如果想变成大根堆，可以将每个元素变成相反数</span><br><span class="line">heapreplace(nums, x) # 将堆顶元素替换为x</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make_heap</span>(nums); <span class="comment">//原地堆化 默认是大根堆</span></span><br><span class="line"><span class="built_in">pop_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); # 将堆顶元素调整值末尾</span><br><span class="line">nums.<span class="built_in">back</span>() = nums.<span class="built_in">back</span>() + <span class="number">999</span>;</span><br><span class="line"><span class="built_in">push_heap</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); # 将修改的元素添加到堆中</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">h</span> = BinaryHeap::<span class="title function_ invoke__">from</span>(nums);<span class="comment">//原地堆化 默认是大根堆</span></span><br><span class="line">h.<span class="title function_ invoke__">push</span>(x);<span class="comment">//向堆中添加元素x</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span> = h.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();<span class="comment">//弹出堆顶元素并返回元素赋值给t</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t2</span> = *h.<span class="title function_ invoke__">peek</span>().<span class="title function_ invoke__">unwrap</span>();<span class="comment">//取出堆顶的元素，不弹出</span></span><br></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1>]]></content>
      
      
      <categories>
          
          <category> 各种语法杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB常见使用命令</title>
      <link href="/2023/09/19/GDB%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/09/19/GDB%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB调试工具"><a href="#GDB调试工具" class="headerlink" title="GDB调试工具"></a>GDB调试工具</h1><h2 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h2><ul><li><p>GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</p></li><li><p>一般来说，GDB 主要帮助你完成下面四个方面的功能：</p></li></ul><ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序</li><li>可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式)</li><li>当程序被停住时，可以检查此时程序中所发生的事</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>通常，在为调试而编译时，我们会()关掉编译器的优化选项（<code>-O</code>）, 并打开调试选项(<code>-g</code>)。另外，<code>-Wall</code>在尽量不影响程序行为的情况下选项打开warning, 也可以发现许多问题，避免一些不必要的BUG。</li><li>gcc -g -Wall program.c -o program</li><li><code>-g</code> 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</li></ul><h2 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h2><h3 id="启动和退出、查看代码"><a href="#启动和退出、查看代码" class="headerlink" title="启动和退出、查看代码"></a>启动和退出、查看代码</h3><ul><li>启动和退出<br>  gdb 可执行程序<br>  quit</li><li>设置/获取参数<br>  set args 10 20<br>  show args</li><li>GDB 使用帮助<br>  help</li><li>查看文件代码<ul><li>查看当前文件代码(使用list查看代码时，文件必须与调试的程序在同一个路径中)<br>  list/l 从默认位置显示<br>  list/l 行号 从指定的行号显示<br>  list/l 函数名 从指定的函数显示</li><li>查看非当前文件代码<br>  list/l 文件名:行号<br>  list/l 文件名:函数名</li></ul></li><li>设置显示的行数<br>  show list/listsize<br>  set list/listsize 行数<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3></li><li>设置断点<br>  b/break 行号<br>  b/break 函数名<br>  b/break 文件名:行号<br>  b/break 文件名:函数</li><li>查看断点<br>  i/info b/break</li><li>删除断点<br>  d/del/delete 断点编号</li><li>设置断点无效<br>  dis/disable 断点编号</li><li>设置断点生效<br>  ena/enable 断点编号</li><li>设置条件断点（一般在循环的位置）<br>  b/break 10 if i == 5<h3 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h3></li><li>运行GDB程序<br>  start 程序停在第一行<br>  run 遇到断点才停</li><li>继续运行，到下一个断点停<br>  c/continue</li><li>向下执行一行代码 (不会进入函数体)<br>  n/next</li><li>变量操作<br>  p/print 变量名<br>  ptype 变量（打印变量类型）</li><li>向下单步调试（遇到函数进入函数体)<br>  s/step<br>  finish(进入函数体)</li><li>自动变量操作<br>  display num (自动打印指定变量的值)<br>  i/info display<br>  undisplay 编号</li><li>其他操作<br>  set var 变量名=变量值<br>  until （跳出循环）</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO与进程同步</title>
      <link href="/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/08/25/IO%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="C-条件变量"><a href="#C-条件变量" class="headerlink" title="C++条件变量"></a>C++条件变量</h1><h2 id="面试高频指数：⭐⭐⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐⭐</h2><ol><li><p>条件变量（<code>condition variable</code>）:<br>在<code>C</code>语言中我们使用<code>pthread_cond_wait</code>函数作为条件变量，它是由操作系统实现的条件变量，需要详细了解它的运行机制就可以了解<code>C++</code>中条件变量的实现。在<code>C++11</code>以后，我们可以使用条件变量(<code>condition_variable</code>)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。<code>C++</code>中包含的头文件<code>#include&lt;condition_variable&gt;</code>中。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两种动作：</p><ul><li>一个线程因等待条件变量的条件成立而挂起：</li><li>另外一个线程使<strong>条件成立</strong>从而给出线程的信号，从而唤醒被等待的线程；</li><li>为了防止竞争，条件变量的使用总是和一个互斥锁在一起；通常情况下这个锁是<code>std::mutex</code>, 并且管理这个锁只能是<code>std::unique_lock std::mutex</code>等<code>RAII</code>模板类，分别是使用以下两个方法实现：<ul><li>等待条件成立使用的<code>condition_variable</code>类成员<code>wait</code>或者<code>wait_for</code>或<code>wait_until</code>。</li><li>唤醒信号使用的是<code>condition_variable</code>类成员<code>notify_one</code>或者<code>notify_all</code>函数。<br><code>condition_variable</code>支持的函数如下：<ul><li>构造函数：它只有一个默认构造函数，拷贝构造函数和赋值符号重载均被禁止<code>condition_variable(const  condition_variable&amp;) = delete;</code>，<code>opterator= [delete]</code>;</li><li><code>wait</code>：<code>wait</code>目前支持<code>wait</code>，<code>wait_for</code>, <code>wait_until</code>等三种操作，分别对应不同的场景；</li></ul></li></ul></li><li><code>wait</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock)</span></span></span><br></pre></td></tr></table></figure>当前线程执行时就被阻塞，直到等到被<code>notify</code>唤醒，在阻塞线程的那一刻，该函数自动调用lck.unlock()，允许其他被<code>lck</code>锁定的线程继续运行。阻塞时被一旦某个线程<code>notify</code>时， 实际可能为虚假唤醒，该函数将解除阻塞并调用<code>lck.lock()</code>，获取互斥锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>调用时检查<code>pred</code>，如果<code>false</code>，则阻塞线程，并且调用<code>lock.unlock()</code>，否则，继续执行。阻塞时被一旦某个线程<code>notify</code>时，实际可能为虚假唤醒，该函数将再次检查<code>pred</code>，如果为<code>true</code>，则解除阻塞并调用<code>lck.lock()</code>，获取互斥锁；否则继续阻塞线程。</li><li><code>wait_for</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">        Predicate stop_waiting)</span></span>;</span><br></pre></td></tr></table></figure>调用时，检查两个条件是否满足：<code>stop_waiting</code>返回是否<code>true</code>, 时间是否超时，如果两个条件都不满足，则阻塞线程，并调用<code>lock.unlock()</code>，否则，到达一定等待时间或满足条件被唤醒。注意等待超过时间段后自动唤醒，判断条件一般需要使用者自己在合适的时候判断，并通过<code>notify_one()</code>或<code>notify_all()</code>唤醒，所以在使用时应当通过判断返回值来检测是其由于超时返回还是正常唤醒，即状态是否为<code>std::cv_status::timeout</code>。程序示例如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex cv_m;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waits</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;<span class="comment">//使用std::unique_lock&lt;std::mutex 来管理std::mutex</span></span><br><span class="line">    <span class="keyword">if</span> (cv.<span class="built_in">wait_for</span>(lk, idx*<span class="number">100</span>ms, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; finished waiting. i == &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Thread&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; timed out. i == &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">120</span>ms);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Notifying...\n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Notifying again...\n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waits, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(waits, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(waits, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(signals)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();<span class="comment">//t1 等待 100ms 后被唤醒，自动超时</span></span><br><span class="line">    t2.<span class="built_in">join</span>();<span class="comment">//t2 在120ms 处被唤醒，但condition未满足，再次进入阻塞，200ms 时由于超时返回</span></span><br><span class="line">    t3.<span class="built_in">join</span>();<span class="comment">//t3 在120ms 处被唤醒，但condition未满足，再次进入阻塞，220ms时被通知，正常返回。</span></span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread1 timed out. i == 0</span></span><br><span class="line"><span class="comment">Notifying...</span></span><br><span class="line"><span class="comment">Thread2 timed out. i == 0</span></span><br><span class="line"><span class="comment">Notifying again...</span></span><br><span class="line"><span class="comment">Thread3 finished waiting. i == 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><code>wait_until</code>：对应的函数原型为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure><code>wait_for</code>是通过<code>wait_until</code>实现的，到达指定截止时间或者满足条件<code>conditions</code>时线程即被唤醒。不同的是，到达时间是自动唤醒，而条件满足<code>conditions</code>时则是通过<code>notify_one()</code>或<code>notify_all()</code>唤醒，使用的时候要注意判断返回值，根据返回值确定该线程是被超时唤醒还是被其他线程<code>notify</code>正常唤醒，即状态是否为<code>std::cv_status::timeout</code>。</li><li><code>notify</code>:<pre><code>  - `notify_one` 唤醒一个阻塞的线程，唤醒线程的顺序可能是随机的，并没有特定的顺序。  - `notify_one` 程序示例如下，我们可以看到每次唤醒的顺序并不是确定的;</code></pre></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//condition_variable notify_one</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produce, consume;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cargo = <span class="number">0</span>;<span class="comment">//shared value producers and consumers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cargo == <span class="number">0</span>) consume.<span class="built_in">wait</span>(lck);</span><br><span class="line">    std::cout &lt;&lt; cargo &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cargo = <span class="number">0</span>;</span><br><span class="line">    produce.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (cargo != <span class="number">0</span>) produce.<span class="built_in">wait</span>(lck);</span><br><span class="line">    cargo = id;</span><br><span class="line">    consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread consumers[<span class="number">10</span>], producers[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//spawn 10 consumes and 10 produces</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        consumers[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">        producers[i] = std::<span class="built_in">thread</span>(producer, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//join them back:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        producers[i].<span class="built_in">join</span>();</span><br><span class="line">        consumers[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>notity_all</code>唤醒所有的线程在<code>condition_variable</code>下的线程。需要特别注意的是，可能唤醒所有阻塞的线程，但是唤醒的多个线程同一时间只能有一个线程可以持有<code>lck</code>锁，必须等待其执行<code>wait</code>之后的代码，并释放<code>lck</code>时，剩余的线程才可以运行，我们可以观察到以下程序示例，唤醒的程序都是随机的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable_any cv;</span><br><span class="line">std::mutex cv_m;</span><br><span class="line"><span class="comment">//This mutex is used for three purposes</span></span><br><span class="line"><span class="comment">//1) to synchronize accesses to i </span></span><br><span class="line"><span class="comment">//2) to synchronize accesses to std::cerr</span></span><br><span class="line"><span class="comment">//3) for the condition variable cv </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waits</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Waiting... \n&quot;</span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;);</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;thread:&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot; ...finished waiting. i == 1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Notifying...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(cv_m)</span></span>;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Notifying again...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waits, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(waits, <span class="number">2</span>)</span>, <span class="title">t3</span><span class="params">(waits, <span class="number">3</span>)</span>, <span class="title">t4</span><span class="params">(signals)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>虚假唤醒以及如何避免虚假唤醒：<br>当线程从等待已发出信号的条件变量中醒来，却发现它等待的条件未得到满足时，就会发生虚假唤醒，发生虚假唤醒通常是因为在发出条件变量信号和等待线程最终运行之间，另一个线程运行并更改了条件，导致<code>wait</code>的线程被唤醒后，实际条件却未满足。比如我们在<code>notify_all()</code>时多个线程都被唤醒，但此时实际共享区却只有少数几个线程可以操作，这时就会造成其他线程被虚假唤醒，可以在<code>wait</code>唤醒后再次进行检测<code>condition</code>解决虚假唤醒。</li></ol><ul><li>虚假唤醒导致的后果：之前要等待的某个条件实际上并没有符合，被唤醒的线程将可能会执行一系列非法操作。</li><li>通常的解决办法：在条件变量阻塞的代码处增加一个<code>while</code>循环，如果被唤醒就要检查一下条件是否符合，如果不符合则要再次进入阻塞等待。这样即避免了忙等待，又避免了虚假唤醒问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(mutex);</span><br><span class="line"><span class="keyword">while</span> (something <span class="keyword">not</span> <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">condition_wait</span>(cond, mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">do</span> (something);</span><br><span class="line"><span class="built_in">unlock</span>(mutex);</span><br></pre></td></tr></table></figure></li></ul><h1 id="线程同步与异步"><a href="#线程同步与异步" class="headerlink" title="线程同步与异步"></a>线程同步与异步</h1><h2 id="面试高频指数：⭐⭐⭐⭐⭐-1"><a href="#面试高频指数：⭐⭐⭐⭐⭐-1" class="headerlink" title="面试高频指数：⭐⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐⭐</h2><p>线程同步操作：<br><code>C++</code>标准库提供了一下几种线程同步的方式：</p><ul><li>互斥量（支持超时加锁、递归加锁）；</li><li>读写锁（共享互斥量，也支持超时加锁）；</li><li>互斥量包装器(基于<code>RAII</code>的思想);</li><li>条件变量;</li><li>信号量（二元信号量、计数信号量）;</li><li><code>barrier</code>;</li><li><code>call_once</code>;</li></ul><p>不同的同步方式具有不同的使用场景和性能，实际使用时根据不同的场景选择不同的同步方式，分别就几种方式以上几种方式进行简要介绍：</p><ol><li><p>互斥量（<code>mutex</code>）:<br> 互斥量 （<code>mutex</code> ）是防止同时访问共享资源的程序对象，为避免线程更新共享变量时所出现问题，必须使用互斥量(<code>mutex</code>是<code>mutal exclusion</code>的缩写)来确保同时仅有一个线程可以访问某项共享资源。即使用互斥量来实现原子访问操作，防止多个线程对临界区同时操作而产生不一致的问题。<code>mutex</code>只有锁定（<code>locked</code>）和未锁定（<code>unlocked</code>）两种状态。任何时候，至多只有一个线程可以锁定互斥量。试图对已经锁定的互斥量再次加锁，将可能阻塞线程或者报错失败。<code>mutex</code>的底层可能封装的是操作系统<code>spinlock</code>，不同的操作系统不可能有不同的实现。<code>C++</code>中关于<code>mutex</code>的头文件为<code>#include &lt;mutex&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_block</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;std::cout&lt;&lt; c;&#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_block, <span class="number">50</span>, <span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">th2</span> <span class="params">(print_block, <span class="number">50</span>, <span class="string">&#x27;$&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">****************************************</span></span><br><span class="line"><span class="comment">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>C++</code>中还定义了<code>timed_mutex</code>： 在<code>mutex</code>的基础上增加了加锁的功能。<br><code>recursize_mutex</code>：在<code>mutex</code>的基础上增加了递归加锁的功能(此时，<code>lock()</code>函数可以在同一线程不释放锁的情况下多次调动)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>共享互斥量：<br><code>std::shared_mutex</code>是<code>C++17</code>标准引入的，由<code>unique_lock</code>和<code>shared_lock</code>两个模板类配合<code>shared_mutex</code>使用，主要用于读写共享锁。<code>unique_lock</code>用于写入是加锁。<code>shared_lock</code>用于读取时加锁，对线工在构造时自动对<code>shared_mutex</code>加锁，析构时自动对其解锁。头文件主要包含在<code>#include &lt;shared_mutex</code>。<code>shared_mutex</code>可用于保护数据不被多个线程同时访问。与其他便于独占访问的互斥锁类型相比，<code>shared_mutex</code>具有两种访问级别：</p></li></ol><ul><li><code>shared</code>：多个线程可以共享同一个互斥锁的所有权。</li><li><code>exclusive</code>：只有一个线程可以拥有互斥锁。<br>共享互斥锁通常用于多个读取操作可以同时访问同一资源而不会导致数据竞争，但只有一个写入操作的场景。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadSafeCounter</span>() = <span class="keyword">default</span>;<span class="comment">//默认构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//多个线程同时读取counter计数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个线程可以修改counter计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个线程可以修改counter计数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex mutex_;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadSafeCounter counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> increment_and_print = [&amp;counter]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            counter.<span class="built_in">increment</span>();</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; counter.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// Note: Writing to std::cout actually needs to be synchronized as well</span></span><br><span class="line">            <span class="comment">// by another std::mutex. This has been omitted to keep the example small.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(increment_and_print)</span></span>;</span><br><span class="line">    </span><br><span class="line">    thread1.<span class="built_in">join</span>();</span><br><span class="line">    thread2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">139677317637888 2</span></span><br><span class="line"><span class="comment">139677317637888 3</span></span><br><span class="line"><span class="comment">139677309245184 4</span></span><br><span class="line"><span class="comment">139677309245184 5</span></span><br><span class="line"><span class="comment">139677309245184 6</span></span><br><span class="line"><span class="comment">139677317637888 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>我们可以看到<code>increment</code>同时只能有一个线程对计数进行增加，但可能同时存在多个线程读取同一个计数。<code>shared_timed_mutex</code>是在<code>shared_mutex</code>的基础上增加了超时加锁功能。</li></ul><ol><li>互斥量包装器<br><code>lock_guard</code>：使用了<code>RAII</code>的机制对互斥量进行类模板封装，构造时加锁，析构时解锁。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mtx is automatically released when lock goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>互斥量包装器对比原生的<code>mutex</code>来说，创建即加锁，作用域结束后自动析构解锁，无需手动解锁。缺点是不能中途解锁，不支持赋值和移动。在需要加锁的地方，只需要任意实例化一个<code>lock_guard</code>，调用构造函数成功上锁，出作用域则<code>lock_guard</code>对象会被销毁，调用析构函数自动解锁从而不会造成死锁，但是提供的功能单一不够灵活。</p><p><code>unique_lock</code>：<code>unique_lock</code>类模板也是采用<code>RAII</code>的方式对锁进行了封装，并且也是以独占所有权的方式管理<code>mutex</code>对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造(或移动<code>move</code>赋值)时，<code>unique_lock</code>对象需要传递一个<code>mutex</code>对象作为他的参数，新创建的<code>unique_lock</code>对象负责传入的<code>mutex</code>对象的上锁和解锁操作。使用以上类型互斥量实例化<code>unique_lock</code>对象时，自动调用构造函数上锁，<code>unique_lock</code>对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题。与<code>lock_guard</code>不同的是，<code>unique_lock</code>更加的灵活，提供了更多的成员函数：</p><ul><li>上锁/解锁操作：<code>lock</code>、<code>try_lock</code>、<code>try_lock_for</code>、<code>try_lock_until</code>和<code>unlock</code>;</li><li>修改操作：支持移动赋值、交换（<code>swap</code>：与另一个<code>unique_lock</code>对象互换所管理的互斥量所有权）、释放（<code>release</code>：返回它所管理的互斥量对象的指针，并释放所有权。）</li><li>获取属性：<code>owns_lock</code>（返回当前对象是否上了锁）、<code>operator bool()</code>  (与<code>owns_lock()</code>)的功能相同)、<code>mutex</code>（返回当前<code>unique_lock</code>所管理的互斥量的指针）。</li></ul><ol><li>条件变量(<code>condition variable</code>)：<br>在<code>C++11</code>以后，我们可以使用条件变量（<code>condition_variable</code>）实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。<code>C++</code>中包含的头文件在<code>#include &lt;condition_variable</code>中。<br>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</li></ol><ul><li>一个线程因等待<code>条件变量的条件成立</code>而挂起：</li><li>另外一个线程使<code>条件成立</code>从而给出唤醒线程的信号，从而唤醒被等到的线程；<br>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是<code>std::mutex</code>，并且管理这个锁只能是<code>std::unique_lock std::mutex</code>等RAII模板类。分别是使用以下两个方法实现：</li><li>等待条件成立使用的是<code>condition_variable</code>类成员<code>wait</code>、<code>wait_for</code>或<code>wait_until</code>。</li><li>唤醒信号使用的是<code>condition_variable</code>类成员<code>notify_one</code>或者<code>notify_all</code>函数。<br>我们可以看到<code>wait</code>函数如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;Class Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate stop_waiting)</span></span>;</span><br></pre></td></tr></table></figure>线程会一直挂起，直到<code>stop_waiting</code>为<code>true</code>为止。程序示例如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::string data;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> processed = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// worker 线程等待 ready</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> ready;&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 唤醒执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing data\n&quot;</span>;</span><br><span class="line">    data += <span class="string">&quot; after processing&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// processed 设置为 true, 唤醒 main 线程</span></span><br><span class="line">    processed = <span class="literal">true</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread signals data processing completed\n&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 释放锁，防止再次被唤醒。</span></span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">// 唤醒 main 线程</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line">    <span class="comment">// 让 worker 线程先执行，再进行唤醒，否则可能出现 ready = true 先于 worker 线程的执行</span></span><br><span class="line">    worker.<span class="built_in">detach</span>();</span><br><span class="line">    </span><br><span class="line">    data = <span class="string">&quot;Example data&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置 ready 为 true, 唤醒 worker 线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;main() signals data ready for processing\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 worker 线程</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="comment">// 等待 worker 线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, []&#123;<span class="keyword">return</span> processed;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back in main(), data = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main() signals data ready for processing</span></span><br><span class="line"><span class="comment">worker thread signals is processing data</span></span><br><span class="line"><span class="comment">.Worker thread signals data processing completed</span></span><br><span class="line"><span class="comment">Back in main(), data = Example data after processing</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>信号量<br><code>C++20</code>中添加了<code>C++</code>中的信号量为二元信号量与计数信号量，二元信号量实际为计数信号量模板的特化。</li></ol><ul><li><code>binary_semphore</code>：二元信号量类似于互斥量，信号量只要0和1。</li><li><code>counting_semphore</code>：计数信号量<br>所有关于信号量的定义参考头文件<code>#include &lt;semaphore&gt;</code>, 计数信号量是一种轻量级同步原语，可以控制对共享资源的访问。与<code>std::mutex</code>不同的是，<code>counting_semphore</code>至少允许<code>LeastMaxValue</code>并发访问者对同一资源进行多个访问。<code>counting_semphore</code>包含一个由构造函数初始化的内部计数器。该计数器可以通过<code>acquire</code>获取资源访问权限，并ton过调用<code>release()</code>来释放资源从而递增计数器。当计数器为零时，调用<code>acquire()</code>时就会阻塞直到计数器增加，但是调用<code>try_acquire()</code>不阻塞;<code>try_acquire_for()</code>和<code>try_acquire_until()</code>阻塞直到计数器增加或达到超时。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::binary_semaphore</span><br><span class="line">smphSignalMainToThread&#123;<span class="number">0</span>&#125;,</span><br><span class="line">smphSignalThreadToMain&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadProc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一次进入阻塞</span></span><br><span class="line">smphSignalMainToThread.<span class="built_in">acquire</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[thread] Got the signal\n&quot;</span>; <span class="comment">// response message</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">3</span>s);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[thread] Send the signal\n&quot;</span>; <span class="comment">// message</span></span><br><span class="line">    <span class="comment">// 唤醒 main 线程</span></span><br><span class="line">smphSignalThreadToMain.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">thrWorker</span><span class="params">(ThreadProc)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[main] Send the signal\n&quot;</span>; <span class="comment">// message</span></span><br><span class="line">    <span class="comment">// 唤醒 ThreadProc </span></span><br><span class="line">smphSignalMainToThread.<span class="built_in">release</span>();</span><br><span class="line">    <span class="comment">// main 线程阻塞</span></span><br><span class="line">smphSignalThreadToMain.<span class="built_in">acquire</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[main] Got the signal\n&quot;</span>; <span class="comment">// response message</span></span><br><span class="line">thrWorker.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[main] Send the signal</span></span><br><span class="line"><span class="comment">[thread] Got the signal</span></span><br><span class="line"><span class="comment">[thread] Send the signal</span></span><br><span class="line"><span class="comment">[main] Got the signal</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>barrier</code>：<br><code>C++ 20</code>以后支持<code>latch</code>与<code>barrier</code>，他们同样是用来线程同步。</li></ol><p><code>latch</code>：类<code>latch</code>是<code>std::pridiff_t</code>类型的向下计数器，可用来同步线程。计数器的值在创建时初始化。其内部维护者一个计数器，当计数器不为0时，所有参与者(线程)都将阻塞在等待操作处，计数为<code>0</code>时，解除阻塞。计数器不可重置或增加，故它是一次性的，不可重用。与<code>std::barrier</code>不同，<code>std::latch</code>参与线程可以多次递减。</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;latch&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//latch是一种倒计时的计数器，它的值在构造函数中设置，线程中可以使用</span></span><br><span class="line">    <span class="comment">//初始值为2</span></span><br><span class="line">    <span class="function">std::latch <span class="title">work_done</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    work_done.<span class="built_in">count_down</span>();<span class="comment">//以非阻塞的方式对计数器进行减1操作 接着继续往下执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//work_done.wait();//当计数值不为0时，就一直阻塞，直到为0才不阻塞（不会减1操作）</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;waiting because the counter is nozero&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="type">bool</span> ok = work_done.<span class="built_in">try_wait</span>();<span class="comment">//测试内部的计数值是否为0 如果为0则返回true 否则返回false 这时还是1 </span></span><br><span class="line">    std::cout &lt;&lt; ok &lt;&lt; std::endl;<span class="comment">//ok = 0</span></span><br><span class="line">    work_done.<span class="built_in">arrive_and_wait</span>();<span class="comment">//递减计数器并阻塞直到它到达0(这里会减1) 这里减1操作后变成0，就不会阻塞了！继续执行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;倒计时结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">倒计时结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p><code>barrier</code>：类似于<code>latch</code>，<strong>它会阻塞线程直到所有参与者线程都达到一个同步点，直到预期数量的线程到达设定的值则会解除阻塞</strong>。与<code>latch</code>不同的是，<strong>它是可重用的</strong>。<br>一个<code>barrier</code>的声明周期包含多个阶段，每个阶段都定义了一个同步点。一个<code>barrier</code>阶段包含：</p><ul><li>期望计数(设创建时指定的计数为<code>n</code>)，当期望计数不为<code>0</code>时，参数者将阻塞与等待操作处</li><li>当期望计数为<code>0</code>时，会执行创建<code>barrier</code>时指定的阶段完成步骤，然后解除阻塞所有阻塞于同步点的参与者线程。</li><li><p>当阶段完成步骤执行完成后，会重置期望计数为<code>n-调用arrive_and_drop()</code>的次数，然后开始下一个阶段</p><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认是初始化列表: initializer_list</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> workers = &#123;<span class="string">&quot;anil&quot;</span>, <span class="string">&quot;busara&quot;</span>, <span class="string">&quot;carl&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; typeid(workers).name() &lt;&lt; endl;//St16initializer_listIPKcE</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> on_completion = []() <span class="keyword">noexcept</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lamda函数 [] 里可接收外部参数 () 里是形参列表，可以自定义参数</span></span><br><span class="line"><span class="comment">    等价于noexcept(true) 注意: 这里括号中可以填写表达式, 值为true 则不会抛出异常，否则会抛出异常</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">auto</span> phase = <span class="string">&quot;...done\n&quot;</span><span class="string">&quot;Cleaning up...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; phase;</span><br><span class="line">        phase = <span class="string">&quot;...done\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ssize(workers): 求初始化列表中的元素个数！</span></span><br><span class="line">    <span class="comment">//barrier对象初始为3个线程同步点！</span></span><br><span class="line">    <span class="function">std::barrier <span class="title">sync_point</span><span class="params">(std::ssize(workers), on_completion)</span></span>;<span class="comment">//当ssize(workers)个线程每完成一个阶段的任务，就会执行一次on_completion函数！！！</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">auto</span> work = [&amp;](std::string name) &#123;</span><br><span class="line">        std::string product = <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; worked\n&quot;</span>;<span class="comment">// anill workded</span></span><br><span class="line">        std::cout &lt;&lt; product;<span class="comment">//ok, op &lt;&lt; call is atomic</span></span><br><span class="line">        <span class="comment">//当 std::arrive_and_wait 在同步点等待时，std::arrive_and_drop 将自己从同步机制中删除</span></span><br><span class="line">        sync_point.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//全部到达后，进行下一阶段 此时内部计数会减少1</span></span><br><span class="line">        product = <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;cleaned\n&quot;</span>;<span class="comment">// anill cleaned</span></span><br><span class="line">        std::cout &lt;&lt; product;</span><br><span class="line">        sync_point.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Starting...\n&quot;</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;<span class="comment">//线程对象数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> <span class="type">const</span>&amp; worker : workers) &#123;<span class="comment">//遍历初始化列表，然后创建线程并传入参数</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(work, worker);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);<span class="comment">//每个1s实例化线程对象 当线程数小于3时，每个线程会卡在第一阶段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads) &#123;<span class="comment">//让主线程等待子线程结束然后回收资源</span></span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Starting...</span></span><br><span class="line"><span class="comment">这里是3个线程均执行第一阶段的任务</span></span><br><span class="line"><span class="comment"> anil worked</span></span><br><span class="line"><span class="comment"> busara worked</span></span><br><span class="line"><span class="comment"> carl worked</span></span><br><span class="line"><span class="comment">3个线程第一阶段的任务都执行完了，此时打印on_completion函数的内容</span></span><br><span class="line"><span class="comment">...done</span></span><br><span class="line"><span class="comment">Cleaning up...</span></span><br><span class="line"><span class="comment">此时内部计数会减少1。然后只需要两个线程执行就可以印on_completion了！！！</span></span><br><span class="line"><span class="comment">然后这三个线程开始执行第二阶段的任务</span></span><br><span class="line"><span class="comment"> busaracleaned</span></span><br><span class="line"><span class="comment"> carlcleaned</span></span><br><span class="line"><span class="comment"> anilcleaned</span></span><br><span class="line"><span class="comment"> 第二段任务结束后，再次打印on_completion函数的内容，因为内部是静态字符串，第二次不再执行初始化操作</span></span><br><span class="line"><span class="comment"> 直接打印第一次修改后的字符串值</span></span><br><span class="line"><span class="comment">...done</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><code>call_once</code><br><code>C++11</code>以后支持<code>call_once</code>。确保某个操作只被执行一次(成功执行才算), 即使是多线程环境下也确保只执行一次。<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Callable</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>如果在<code>call_once</code>被调用时，<code>flag</code>表明<code>f</code>已经被调用，则<code>call_once</code>立即返回(这种调用<code>call_once</code>称为被动)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class Callable, class... Args&gt;</span></span><br><span class="line"><span class="comment">void call_once(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args);</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is running simple_do_once&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//这个</span></span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []() &#123; std::cout &lt;&lt; <span class="string">&quot;simple example: called once\n&quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hhhhhh &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的线程都会执行simple_do_once的函数，只是call_once这个只会被某一个线程函数执行一次！！！其他线程函数就会忽略掉这一行！！！！</span></span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="多线程异步"><a href="#多线程异步" class="headerlink" title="多线程异步"></a>多线程异步</h1><h2 id="面试高频指数：⭐⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐</h2><hr><ol><li><p><code>std::thread</code></p><p>我们可以通过<code>thread</code>创建一个线程(<code>C++11</code>以后才支持<code>thread</code>标准库)，<code>thread</code>在构造相关线程对象完成后立即开始执行(<strong>实际需要等待<code>OS</code>对于线程的调用延迟</strong>)。<code>thread</code>需要配合与<code>join</code>或者<code>detach</code>配合使用，不然可能出现不可预料的后果。</p><ul><li><code>join</code> 代表阻塞当前主线程，等待当前的<code>join</code>的子线程完成后主线程才会继续</li><li><code>detach</code>表明当前子线程不阻塞主线程，且与主线程分离，子线程的运行不会影响到主线程。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn2</span> <span class="params">(string st2)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; st2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn1</span> <span class="params">(string st1)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; st1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thr1</span><span class="params">(fn1, <span class="string">&quot;11111111\n&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">thr2</span><span class="params">(fn2, <span class="string">&quot;22222222\n&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//thr1.join();</span></span><br><span class="line">    <span class="comment">//thr2.join();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">当没有join或者detach时，会报如下错误</span></span><br><span class="line"><span class="comment">terminate called without an active exception</span></span><br><span class="line"><span class="comment">11111111</span></span><br><span class="line"><span class="comment">Aborted</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">否则正常打印</span></span><br><span class="line"><span class="comment">11111111</span></span><br><span class="line"><span class="comment">22222222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如<strong>在一个类中间，一个成员函数需要<code>异步调用</code>另一个函数的时候，需要绑定<code>this</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> std::string s1, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;<span class="comment">//类中的该成员函数调用另一个成员函数，绑定了this!!!</span></span><br><span class="line">        <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;Test::func1, <span class="keyword">this</span>, <span class="string">&quot;dog&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        t1.<span class="built_in">join</span>();<span class="comment">//这里为join时，就会先去执行func1，执行完后再去执行fun2后续逻辑。那么结果始终是dog 0\n func2</span></span><br><span class="line">        <span class="comment">//t1.detach(); 当这里为detach打印的结果是不可预知的！！！因为fun2执行完了，这里t1对象已经被销毁了，可能执行fun1时会出现问题！！！</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test a;</span><br><span class="line">    a.<span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::async</code></p></li></ol><blockquote><p>我们进行异步编程时，需要得到子进程的计算结果，常见的手段是我们可以通过<strong>共享变量或者消息队列</strong>的方式告知另一个线程当前的计算结果，但是操作和实现都比较麻烦，同时还要考虑线程间的互斥问题。<code>C++11</code>中提供了一个相对简单的异步接口<code>std::async</code>，通过这个接口可以简单地创建线程并通过<code>std::future</code>中获取结果，极大的方便了<code>C++</code>多线程编程。<strong><code>std::async</code>适合于需要取得结果的异步线程</strong>。<code>C++11</code>中的<code>std::async</code>是个模板函数。<code>std::async</code>异步调用函数，<strong>在某个时候以<code>Args</code>作为参数(可变长参数)调用函数，无需等待函数执行完成就可返回，返回结果是个<code>std::future</code>对象。函数返回的值可通过<code>std::future</code>对象的<code>get</code>成员函数获取。一旦完成函数的执行，共享状态将包含函数返回的值并<code>ready</code>。</strong></p></blockquote><p>​        <code>async</code>使用的函数原型和参数说明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(C++11 起)（C++17 前）</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Functon</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>(Function&amp;&amp; f, Args&amp;&amp;... args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>(std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是<code>std::async</code>的启动策略类型有以下两种方式：<code>async</code>允许调用者选择特定的启动策略：</p><ul><li><p><code>std::launch::async</code>：</p><blockquote><p><strong>在调用<code>async</code>就开始创建线程</strong>，该函数由线程异步调用，并且将其返回值与共享状态的访问点同步。</p></blockquote></li><li><p><code>std::launch::deferred</code>：</p><blockquote><p><strong>延迟启动线程，在访问共享状态时该线程才启动</strong>。<strong>对函数的调用将推迟到返回的<code>std::future</code>的共享状态被访问时</strong>（即使用<code>std::future</code>的<code>wait</code>或<code>get</code>函数）。如果<code>get</code>或<code>wait</code>没有被调用，函数就绝对不会执行。</p></blockquote></li></ul></li><li><p>参数<code>Function</code></p><blockquote><p>可以为函数指针、成员指针、任何类型的可移动构造的函数对象，也可以匿名函数<code>lambda</code>。<strong><code>Function</code>的返回值或异常存储在共享状态以供异步的<code>std::future</code>对象检索</strong>。<strong><code>std::future</code>对象可以通过<code>wait</code>或<code>get</code>函数获取函数的返回值。</strong></p></blockquote></li></ul><ul><li><p>参数<code>Args</code></p><blockquote><p>传递给函数<code>Function</code>调用的参数，它们的类型应是可移动构造的。我们可以用多线程程序分为子任务，用子任务求解。</p></blockquote><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个任务分成若干个小任务去执行，每个小任务用新的线程来处理！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallel_sum</span><span class="params">(RandomIt beg, RandomIt end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(beg, end, <span class="number">0</span>);<span class="comment">//当规模小于1000时，就去累加该区间的部分和</span></span><br><span class="line"></span><br><span class="line">    RandomIt mid = beg + len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                             parallel_sum&lt;RandomIt&gt;, mid, end);<span class="comment">//当规模大于1000时，则划分一半开启一个新的线程来处理，如果还是大于1000，则新线程又会创建新的线程来处理</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">parallel_sum</span>(beg, mid);<span class="comment">//计算开始到中间的一半规模的求和。如果规模还是很大，还会创建新的线程来计算较小的和！！！</span></span><br><span class="line">    <span class="keyword">return</span> sum + handle.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同上代码逻辑！！！ 递归+多线程！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parallel_min</span><span class="params">(RandomIt beg, RandomIt end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> len = end - beg;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> *(std::<span class="built_in">min_element</span>(beg, end));</span><br><span class="line"></span><br><span class="line">    RandomIt mid = beg + len / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> handle = std::<span class="built_in">async</span>(std::launch::async,</span><br><span class="line">                             parallel_min&lt;RandomIt&gt;, mid, end);</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">parallel_min</span>(beg, mid);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(ans, handle.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum is &quot;</span> &lt;&lt; <span class="built_in">parallel_sum</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The min elemnet is &quot;</span> &lt;&lt; <span class="built_in">parallel_min</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><code>std::future</code></p><p><strong>通常与<code>std::promise</code>一起使用</strong>：作用是在一个<strong>线程<code>t1</code>中保存一个类型<code>Typename T</code>的值</strong>，<strong>可供相绑定的<code>std::future</code>对象在另一个线程<code>t2</code>中获取</strong></p><blockquote><p><code>std::future</code>提供了一种访问线程异步操作结果的机器。从字面意思来看，<code>future</code>表示未来，<code>std::async</code>返回结果即为一个<code>future</code>。在实际工程项目中，一个异步操作我们是不可能马上就获取操作结果的，只能是在未来的某个时候获取，但是我们可以同步等待的方式来获取结果，可以通过查询<code>future</code>的状态(<code>future_status</code>)来获取异步操作的结果。<code>future_status</code>有三种状态：</p></blockquote><ul><li><p><code>deferred</code>： 异步操作还没开始</p></li><li><p><code>ready</code>：异步操作已经完成</p></li><li><p><code>timeout</code>：异常操作超时</p><blockquote><p>获取<code>future</code>结果有三种方式：<code>get</code>、<code>wait</code>、<code>wait_for</code>，其中</p><p><strong><code>get</code>等待异步操作结束并返回结果</strong></p><p><strong><code>wait</code>只是等待异步操作完成，没有返回值</strong></p><p><strong><code>wait_for</code>是超时等待返回结果</strong></p></blockquote></li></ul></li></ol><pre><code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//future from async </span></span><br><span class="line">    <span class="comment">//使用std::async创建匿名函数的线程函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, [] &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//future from a promise</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;<span class="comment">//确定要在一个线程中设置的值类型为int类型 这个用于传入一个线程，并且在线程里设置值</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f2 = p.<span class="built_in">get_future</span>();<span class="comment">//将future对象绑定！！！</span></span><br><span class="line">    <span class="comment">//这个用于另外一个线程，用于获取与该对应绑定的int类型值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个将p传入匿名函数创建的线程中，并设置值为9</span></span><br><span class="line">    std::<span class="built_in">thread</span>([&amp;p] &#123; p.<span class="built_in">set_value_at_thread_exit</span>(<span class="number">9</span>); &#125;).<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting...&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">    <span class="comment">//等待f1和f2两个异步线程执行完</span></span><br><span class="line">    f1.<span class="built_in">wait</span>();</span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="comment">//分别打印每个异步线程返回的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Done!\nResults are: &quot;</span> &lt;&lt; f1.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f2.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> **std::future与std::promise** <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T = std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&amp;)&gt;;</span><br><span class="line"><span class="comment">//typedef std::function&lt;int(int, int, int&amp;) T;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread fun1 is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    p.<span class="built_in">set_value</span>(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; f)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread fun2 is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waitting for f.get()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//这里会先被执行到，接下来会阻塞在get这里</span></span><br><span class="line">    <span class="comment">//因为fun1在5s过后才会设置值，因此这里会等待！！！</span></span><br><span class="line">    <span class="keyword">auto</span> v = f.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f.get() = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; p;<span class="comment">//定义一个用来保存int的变量</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = p.<span class="built_in">get_future</span>();<span class="comment">//绑定p和f p.set_value() =&gt; f.get()</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(fun1, std::ref(p))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(fun2, std::ref(f))</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//主线程等待子线程运行完才继续执行主线程逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thread fun1 is running...</span></span><br><span class="line"><span class="comment">thread fun2 is running...</span></span><br><span class="line"><span class="comment">waitting for f.get()</span></span><br><span class="line"><span class="comment">f.get() = 999</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></code></pre><h1 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h1><h2 id="面试高频指数：⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐"></a>面试高频指数：⭐⭐⭐</h2><hr><p><code>C++</code>保持与<code>C</code>兼容，因此也保留支持<code>printf</code>和<code>scanf</code>进行输出和输入的方法。<code>C++</code>具有面向对象的特性，引入了新的输入输出。<code>C++</code>通过<code>I/O</code>类库来实现丰富的<code>I/O</code>功能。在<code>C++</code>中，输入和输出以字节序列或更通常称为<code>stream</code>的形式执行。</p><ul><li>输入流（<code>inputstream</code>）：如果字节流的方向是从设备(例如键盘)到主存，那么这个过程称为输入。</li><li>输出流（<code>outputstream</code>）：如果字节流的方向相反，即从主存到设备(显示屏)，那么这个过程称为输出。</li></ul><p><img src="https://cdn.staticaly.com/gh/Horn-JoJo/pic_bed@main/2023/071661515629-ypuTEg-6_1_1.png" alt=""></p><p><code>C++</code>采用了面向对象的思想对所有涉及<code>I/O</code>的操作进行了统一的封装，涉及到<code>I/O</code>操作的主要由<code>&lt;iostream&gt;, &lt;iomanip&gt;, &lt;fstream&gt;</code>三个头文件组成，<code>stream</code>是其行为由类定义的对象，其中主要的类的继承关系如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/Horn-JoJo/pic_bed@main/2023/071661515645-WNnqbw-6_1_2.png" alt=""></p><p><code>C++</code>中的<code>Streams</code>对象主要分为三种类型：</p><ul><li><code>istream</code>：这种类型的流对象只能从流中执行输入操作</li><li><code>ostream</code>：这种对象只能用于输出操作</li><li><code>iostream</code>：可用于输入和输出操作</li></ul><ol><li><p>标准输入输出</p><ul><li>标准输出流(<code>cout</code>)：通常标准输出设备是显示器。<code>C++ cout</code>语句是<code>ostream</code>类的实例。它用于在标准输出设备上产生输出。需要在屏幕上显示的数据使用插入运算符(<code>&lt;&lt;</code>)插入到标准输出流(<code>cout</code>)中。</li><li>标准输入流(<code>cin</code>)：通常计算机中的输入设备是键盘。<code>C++ cin</code>语句是<code>istream</code>类的实例，用于从标准输入设备(通常是键盘)读取输入。提取运算符(<code>&gt;&gt;</code>)与对象<code>cin</code>一起用于读取输入。提取运算符从使用键盘输入的对象<code>cin</code>中提取数据。</li></ul></li><li><p><code>I/O</code>重定向</p><ul><li><p>获取<code>A</code>的流缓冲区并将其存储在某处</p></li><li><p>将<code>A</code>的流缓冲区设置为<code>B</code>的流缓冲区</p></li><li><p>如果需要将<code>A</code>的流缓冲区重置为其先前流缓冲区</p><p>我们可以使用函数<code>ios::rdbuf()</code>来执行一下两个操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream_object.<span class="built_in">rdbuf</span>();<span class="comment">//获取返回指向stream_object的流缓冲区的指针</span></span><br><span class="line">stream_object.<span class="built_in">rdbuf</span>(streambuf *p);<span class="comment">//将流缓冲区设置为p指向的</span></span><br></pre></td></tr></table></figure></li></ul><p>以下为程序示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fstream file;</span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;cout.txt&quot;</span>, ios::out);</span><br><span class="line">    string line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存cin和cout的缓冲区buffer</span></span><br><span class="line">    streambuf* stream_buf_cout = cout.<span class="built_in">rdbuf</span>();</span><br><span class="line">    streambuf* stream_buf_cin = cin.<span class="built_in">rdbuf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件file的缓冲区buffer </span></span><br><span class="line">    streambuf* stream_buf_file = file.<span class="built_in">rdbuf</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout 重定向输出到文件file</span></span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(stream_buf_file);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The cout is redirected to file&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复重定</span></span><br><span class="line">    cout.<span class="built_in">rdbuf</span>(stream_buf_cout);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>C/C++</code>如何清除输入缓冲区</p><blockquote><p>所有标准输入和标准输出都包含一个输入和输入缓冲区。在标准<code>C/C++</code>中，流被缓冲，例如在标准输入的情况下，当我们按下键盘上的键时，它不会发送到您的程序，而是由操作系统发送到缓冲区，直到进程调度时才会将其分配该程序(理解输了很多次，过了一段时间后才显示)。</p><p>在各种情况下，可能需要清除不需要的缓冲区，以便在所需的程序中立即获取下一个输入，而不是在前一个变量的缓冲区中。比如<code>C</code>遇到<code>scanf()</code>后，需要输入字符数组或字符，<code>C++</code>遇到<code>cin</code>语句后，需要输入字符数组或字符。当我们从键盘获取一个字符串时，我们需要清除输入缓冲区，否则所需的输入被前一个变量的缓冲区占用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch,<span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码没有正确打印出字符串<code>ch</code>的值，原因是缓冲区被占用。<code>\n</code>字符保留在缓冲区中，并作为下一个输入读取，因此我们在需要在输入<code>ch</code>之前，将缓冲区进行清除。</p><ul><li>使用<code>cin.ignore</code>：</li><li>使用<code>cin.ignore(numeric_limits::max(), &#39;\n&#39;)</code>，在<code>cin</code>语句之后丢弃输入流中的所有内容，包括换行符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>cin&gt;&gt;ws</code>：</p><p>在<code>cin</code>语句之后输入<code>cin&gt;&gt;ws</code>告诉编译器忽略缓冲区丢弃字符串或字符数组实际内容之前的所有空格。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; ws;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">80</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 面试突破 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO与进程同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统背景&amp;系统架设</title>
      <link href="/2023/08/24/linux/"/>
      <url>/2023/08/24/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h2><ul><li>CPU(运算器、控制器)</li><li>存储器（内存、硬盘）</li><li>输入设备（键盘、鼠标）</li><li>输出设备（显示器）</li></ul><h2 id="软件部分"><a href="#软件部分" class="headerlink" title="软件部分"></a>软件部分</h2><ul><li>操作系统<ul><li>windows：对硬件要求低。商业软件</li><li>unix：对硬件要求高，商业软件</li><li>linux：对硬件要求低，开源免费<ul><li>开源免费</li><li>系统迭代更新</li><li>系统性能稳定</li><li>安全性高</li><li>多任务多应用</li><li>耗资源少</li><li>内核小</li><li>应用领域广泛</li><li>使用及入门简单</li></ul></li></ul></li><li>软件程序</li><li>数据库系统</li></ul><h1 id="linux发行版"><a href="#linux发行版" class="headerlink" title="linux发行版"></a>linux发行版</h1><ol><li>Red Hat Linux</li><li><strong>CentOS（专为为企业社区开发的， 服务器领域基本用的是centOS）</strong></li><li>Ubuntu（程序员爱用）</li><li>SUSE Linux</li><li>Fodora Linux</li><li>Rocky Linux</li><li>Debian Linux</li><li>Kail Linux(黑客同学爱用)</li></ol><h2 id="linux磁盘分区"><a href="#linux磁盘分区" class="headerlink" title="linux磁盘分区"></a>linux磁盘分区</h2><p>查看磁盘分区 ：<code>fdisk -l</code></p><ul><li>MBR方式引导<br>主分区至少有1个，最多4个，单个分区不能超过2TB</li><li>GPT方式引导<br>主分区没有上限，但是Windows限制为128个</li></ul><h1 id="系统部署"><a href="#系统部署" class="headerlink" title="系统部署"></a>系统部署</h1><blockquote><p>CentOS7 8.x系统安装</p><ul><li>VMware软件安装和部署</li><li>CentOS7 8.x镜像下载</li><li>创建虚拟的计算机硬件平台</li><li>安装linux系统&amp;设置linux分区<ul><li>设置分区：<ul><li>根路径：/ (生产环境给40GB)  </li><li>boot路径：/boot </li><li>data路径： /data </li><li>/swap（很多生产环境中设为0）</li></ul></li></ul></li><li>设置Linux Root 用户密码</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sizeof和strlen的区别</title>
      <link href="/2023/08/23/sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/08/23/sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="面试高频指数：⭐⭐⭐⭐⭐"><a href="#面试高频指数：⭐⭐⭐⭐⭐" class="headerlink" title="面试高频指数：⭐⭐⭐⭐⭐"></a>面试高频指数：⭐⭐⭐⭐⭐</h2><ul><li><code>strlen</code>是头文件<code>&lt;cstring&gt;</code>中的函数，<code>sizeof</code>是<code>C++</code>中的运算符。<strong><code>strlen</code>测量的是字符串的实际长度</strong>（源代码如下），以<code>\\0</code>结束，而<strong><code>sizeof</code>测量的是对象或者表达式类型占用的字节大小</strong>。<code>strlen</code>源代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++) </span><br><span class="line">        ++length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl;<span class="comment">//5字节</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;<span class="comment">//10字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>若字符数组arr作为参数的形参，<code>sizeof(arr)</code> 中 ·arr·被当作字符指针来处理。<code>strlen(str)</code> 中<code>arr</code>依然是字符数组，从下述程序的运行结果中就可以看出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">size_of</span><span class="params">(<span class="type">char</span> arr[])</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;<span class="comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27;will return size of &#x27;char*&#x27; .</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">size_of</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><ul><li>两者的不同之处<ul><li><code>strlen</code>本身是库函数，因此在程序运行过程中，计算长度；而<code>sizeof</code>是在编译时计算长度；<code>sizeof</code>的参数可以是类型，也可以是变量，且必须是完整类型；<code>strlen</code>的参数必须是<code>char *</code>类型的变量。</li><li><code>sizeof</code>接受的参数可以是对象也可以是表达式，但是<strong><code>sizeof(expression)</code>在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小</strong>；而<strong><code>strlen</code>是一个函数，如果接受表达式则会对表达式进行运算。</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span> (++x) &lt;&lt; endl;<span class="comment">//不会对表达式进行计算！！！！ 4</span></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl; <span class="comment">//5</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p = s;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(++p) &lt;&lt; endl;<span class="comment">//7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);<span class="comment">//&quot;2345678&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>对于<code>C99</code>中结构体允许最后一个变量为不定长数组，<code>sizeof</code>则不计算空间。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flexarray</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> array[]; <span class="comment">/* Flexible array member; must be last element of struct */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&#x27;\n&quot;</span>, <span class="built_in">sizeof</span> (<span class="keyword">struct</span> flexarray));<span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<br>1.sizeof是c++自带的运算符，strlen()是<cstring>库里的函数<br>2.sizeof在编辑阶段计算长度，strlen()在程序执行阶段计算长度<br>3.sizeof可以接收的参数可以是数据类型（int,long,char<em> 指针等）和表达式，不会计算表达式的值,结果是表达式数据类型的占位长度。strlen()参数是char</em>类型变量，会把表达式计算出来。<br>4.strlen()不会计算’\0’,sizeof会计算。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 面试突破 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关键字和关键库函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux高并发服务器开发</title>
      <link href="/2023/08/19/linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/19/linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li>进程间通信的方式？</li><li>僵尸进程、孤儿进程</li><li>线程同步怎么解决？</li><li>大端和小端的区别？</li><li>IO多路复用有哪些方式？区别？</li><li>静态库跟共享库的制作以及使用</li><li>滑动窗口的机制</li><li>TCP三次握手、四次挥手</li><li>TCP和UDP的区别</li></ol></blockquote><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><hr><div class="markmap-container" style="height:undefined">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;linux高并发服务器开发&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;第一章 linux系统编程入门&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;第二章 linux多进程开发&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;第三章 linux多线程开发&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;第四章 linux网络编程&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;第五章 项目实战和总结&quot;}]}"></svg></div><h1 id="linux环境开发搭建"><a href="#linux环境开发搭建" class="headerlink" title="linux环境开发搭建"></a>linux环境开发搭建</h1><h2 id="linux环境开发搭建-1"><a href="#linux环境开发搭建-1" class="headerlink" title="linux环境开发搭建"></a>linux环境开发搭建</h2><ol><li>安装linux系统</li><li>安装xshell、xftp</li><li>安装Visual Studio Code</li></ol><ul><li>生成ssh密钥：<code>ssh-keygen -t rsa</code></li><li>添加授权密钥：<code>vim anthorized_keys</code> 然后添加对应的授权的公钥</li></ul><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><ul><li>代码编译过程<br><img src="https://article.biliimg.com/bfs/article/4c504497fac5ba6a6828b7957373906c838d3a67.png" alt="image-20230821191355193"></li></ul><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p><code>gcc main.c -E -o -main.i</code> ：宏替换以及展开头文件</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>gcc main.i -S  -o main.s</code>：编译成汇编代码</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p><code>gcc main.s -c main.o</code>： 将汇编代码编译成二进制目标文件, 不能执行，因为可能还需要启动代码、库代码、以及其他目标代码通过链接器然后最终链接成可执行程序。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>gcc main.o -o main</code> ： 将二进制代码与所需要的库文件合并，生成最终的可执行代码。</p><p><strong>注意：汇编和链接可以通过<code>-s</code>直接来合并汇编和链接阶段。 </strong></p><h3 id="gcc-与-g-的区别"><a href="#gcc-与-g-的区别" class="headerlink" title="gcc 与 g++的区别"></a>gcc 与 g++的区别</h3><blockquote><p>gcc 和 g++ 都是GNU的编译器</p><ul><li><strong>误区1</strong>:  gcc 只能编译c代码，g++只能编译g++代码。(这是错误的说法！！！)<ul><li>后缀为c的文件，gcc当作c程序，g++当作c++程序</li><li>后缀为cpp的文件，两者都会当成c++程序</li><li>编译阶段，g++会调用gcc。对于c++代码，两者是等价的，但是gcc不能自动和c++程序使用的库链接，所以通常使用g++来完成编译链接。<strong>这给了一个错误，cpp程序只能由g++编译链接。</strong></li></ul></li></ul></blockquote><ul><li><p><strong>误区二</strong>：gcc不会定义_cplusplus 宏，而g++会(这是错误的！！！)</p><ul><li>实际上，这个宏是告诉编译器要将其编译成c语法还是cpp语法</li><li>如上所述，如果后续后缀为c，并且采用gcc编译，则该宏是未定义的，否则<strong>如果是cpp程序，则使用gcc编译的时候，会定义这样的宏！！！</strong>(编译汇编阶段！！！)</li></ul></li><li><p><strong>误区三</strong>：编译只能用gcc, 链接只能用g++（这是错误的！！！）</p><ul><li>应该这样说会更好：编译可以用g++/gcc，而链接可以用g++ 或者gcc -lstd++（<strong>手动链接stdc++库</strong>）</li><li>gcc 命令不能自动和c++程序使用的库链接，所以通常使用g++来完成链接。<strong>但在编译汇编阶段，g++会自动调用gcc,两者等价</strong></li></ul></li></ul><h3 id="常见参数选项"><a href="#常见参数选项" class="headerlink" title="常见参数选项"></a>常见参数选项</h3><ol><li>-E：预处理</li><li>-S:：编译</li><li>-c：汇编</li><li>-s：汇编链接</li><li>-o：重命名或者链接</li><li>-g：调试</li><li>-w：不显示警告信息</li><li>-Wall：生成所有警告信息</li><li>-On：n可以取0~3, 编译的优化级别从低到高，-O0表示没有优化，-O1时缺省值，-O3优化级别最高（优化可以提高逆向工程难度）</li><li>-D：程序编译的时候，指定一个宏, (这个宏是在程序中定义的：<code>#ifdef DEBUG #endif</code>)</li><li>-I：指定包含头文件目录</li><li>-L 指定包含的库文件路径</li><li>-l+库名：链接阶段链接该库文件</li><li>-fPIC/fpic：生成与位置无关的代码</li><li>-shared：生成目标共享文件，通常用在建立共享库时</li><li>-std：指定c方言：如：-std=c99，gcc默认的方言是GNU C</li></ol><h2 id="静态库的制作和使用"><a href="#静态库的制作和使用" class="headerlink" title="静态库的制作和使用"></a>静态库的制作和使用</h2><h2 id="动态库的制作和使用"><a href="#动态库的制作和使用" class="headerlink" title="动态库的制作和使用"></a>动态库的制作和使用</h2><h2 id="静态库和动态库的对比"><a href="#静态库和动态库的对比" class="headerlink" title="静态库和动态库的对比"></a>静态库和动态库的对比</h2><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/08/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式及实现"><a href="#单例模式及实现" class="headerlink" title="单例模式及实现"></a>单例模式及实现</h1><h2 id="面试指数：⭐⭐⭐⭐⭐"><a href="#面试指数：⭐⭐⭐⭐⭐" class="headerlink" title="面试指数：⭐⭐⭐⭐⭐"></a>面试指数：⭐⭐⭐⭐⭐</h2><p><strong>单例模式</strong>：保证类的实例化对象仅有一个，并且提供一个他的全局访问点。<br><strong>应用场景</strong>：</p><ul><li>表示文件系统的类，一个操作系统一定是只有一个文件系统的，因此文件系统的类的实例只有一个。</li><li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。<br><strong>实现方式</strong>：<br>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</li><li><strong>默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的</strong>，这样禁止在类的外部创建该对象；</li><li>全局访问点也要定义或<strong>静态类型的成员函数</strong>, 没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li></ul><p>不安全的实现方式：<br>原因：考虑两个线程同时调用<code>getInstance</code>方法，并且同时检测到<code>instance</code>是<code>NULL</code>, 两个线程会同时实例化对象，不符合单例模式的要求。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line">    Singleton&amp; opterator=(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton * <span class="built_in">getInstance</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><br>分类：</p><ul><li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li><li>饿汉模式：类定义的时候就实例化。</li></ul><p>线程安全的懒汉模式实现：<br>方法：<code>加锁</code><br>存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程被阻塞。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line">    Singleton&amp; opterator=(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstance</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::intance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Singleton::mutex;</span><br></pre></td></tr></table></figure><br>方法：<strong>内部静态变量</strong>，在全局访问点<code>getInstance</code>中定义静态实例。<br><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);<span class="comment">//其实这里没有用到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp);</span><br><span class="line">    Singleton&amp; opterator=(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstance</span>() &#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Singleton::mutex;</span><br></pre></td></tr></table></figure><br>饿汉模式的实现：<br>饿汉模式本身就是线程安全的不用加锁。<br><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; tmp) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstance</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure><br><strong>总结</strong>：</p><ul><li>单例模式就是只能有一个实例，并且通过全局的或者静态的方式实现(如类中的静态类)</li><li>单例模式分为懒汉模式(只有用的时候才去创建)和饿汉模式（不管用不用直接创建）<ul><li>懒汉模式本身不安全，需要加锁，但是也会存在一些问题</li><li>饿汉模式本身是安全的，直接一开始就在类外创建类中的静态类实例。</li></ul></li></ul><h1 id="工厂模式以及实现"><a href="#工厂模式以及实现" class="headerlink" title="工厂模式以及实现"></a>工厂模式以及实现</h1><h2 id="面试指数：⭐⭐⭐⭐"><a href="#面试指数：⭐⭐⭐⭐" class="headerlink" title="面试指数：⭐⭐⭐⭐"></a>面试指数：⭐⭐⭐⭐</h2><p><strong>工厂模式</strong>：包括简单工厂模式、抽象工厂模式、工厂方法模式。<br><strong>简单工厂模式</strong>：主要用于创建对象，用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的效果。<br><strong>工厂方法模式</strong>：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。<br><strong>抽象工厂模式</strong>：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul><li>主要用于创建对象。用一个工厂来根据输入的条件产生不同的类， 然后根据不同类的虚函数得到不同的结果。</li><li><p><strong>应用场景</strong>：<br>  适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如：计算器中对于同样的输入，执行不同的操作，如加减乘除。<br>  <img src="https://pic.leetcode-cn.com/1661310698-GtQGFs-7_3_1.png" alt="如图所示"></p></li><li><p><strong>实现方式</strong>：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Here is the product class</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="type">int</span> val1, val2;</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Add_Operation</span> : <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> val1 + val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Sub_Operation</span> : <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> val1 - val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Mul_Operation</span> : <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> val1 * val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Div_Operation</span> : <span class="keyword">public</span> Operation &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> val1 / val2;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">static</span> Operation* <span class="title">CreateProduct</span><span class="params">(<span class="type">char</span> op)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ADD_Opeartion</span>();</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Opeartion</span>();</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Opeartion</span>();</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Opeartion</span>();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ADD_Opeartion</span>();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> a, b;</span><br><span class="line">     cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     Operation *p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;+);</span></span><br><span class="line"><span class="string">     p-&gt;val1 = a;</span></span><br><span class="line"><span class="string">     p-&gt;val2 = b;</span></span><br><span class="line"><span class="string">     cout &lt;&lt; p-&gt;GetResult() &lt;&lt; endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     p = Factory::CreateProduct(&#x27;</span>-);</span><br><span class="line">     p-&gt;val1 = a;</span><br><span class="line">     p-&gt;val2 = b;</span><br><span class="line">     cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">     p-&gt;val1 = a;</span><br><span class="line">     p-&gt;val2 = b;</span><br><span class="line">     cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">     p-&gt;val1 = a;</span><br><span class="line">     p-&gt;val2 = b;</span><br><span class="line">     cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>修正了简单工厂模式中不遵守开放封闭原则。把选择判断移动到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p></blockquote></li><li><p><strong>应用场景</strong>：</p><ul><li>一个类不知道他所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端知道创建具体产品的工厂类。</li><li>一个类通过其派生类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象，利用面向对象的多态性和里式代换规则，在程序运行时，派生类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给工厂派生类中的某一个，客户端在使用时可以无须关心是哪一个工厂派生类创建产品派生类，需要时再动态绑定，可将具体工厂类的类名存储在配置文件中或数据库中。<br><img src="https://pic.leetcode-cn.com/1661310755-vFtGMk-7_3_2.png" alt="pic"></li><li><p>实现方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here is the product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val1, val2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation</span>: <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 + val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation</span>: <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 - val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation</span>: <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 * val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation</span>: <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 / val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚基类：工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation* <span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sub_Operation;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation* <span class="title">CreateProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation* p_pro = p_fac-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro-&gt;val1 = a;</span><br><span class="line">    p_pro-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Mul_Factory *p_fac1 = <span class="keyword">new</span> <span class="built_in">Mul_Factory</span>();</span><br><span class="line">    Operation* p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro1-&gt;val1 = a;</span><br><span class="line">    p_pro1-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Sub_Factory *p_fac2 = <span class="keyword">new</span> <span class="built_in">Sub_Factory</span>();</span><br><span class="line">    Operation* p_pro2 = p_fac2-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro2-&gt;val1 = a;</span><br><span class="line">    p_pro2-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro2-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Div_Factory *p_fac3 = <span class="keyword">new</span> <span class="built_in">Div_Factory</span>();</span><br><span class="line">    Operation* p_pro3 = p_fac3-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro3-&gt;val1 = a;</span><br><span class="line">    p_pro3-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro3-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p></blockquote></li></ul></li><li><p>应用场景：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li><li>产品等级结构稳定，设计完成之后，不会像系统中增加新的产品等级结构或者删除已有的产品等级结构。<br><img src="https://pic.leetcode-cn.com/1661310791-KLoZet-7_3_3.png" alt="pic"></li></ul></li><li><p>实现方式：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here is the product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_Pos</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val1, val2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation_Pos</span>: <span class="keyword">public</span> Operation_Pos &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 + val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation_Pos</span>: <span class="keyword">public</span> Operation_Pos &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 - val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation_Pos</span>: <span class="keyword">public</span> Operation_Pos &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 * val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation_Pos</span>: <span class="keyword">public</span> Operation_Pos &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> * val1 / val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*=====================================================*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_Neg</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val1, val2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation_Neg</span>: <span class="keyword">public</span> Operation_Neg &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(val1 + val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation_Neg</span>: <span class="keyword">public</span> Operation_Neg &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(val1 - val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation_Neg</span>: <span class="keyword">public</span> Operation_Neg &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(val1 * val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation_Neg</span>: <span class="keyword">public</span> Operation_Neg &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(<span class="number">1.0</span> * val1 / val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Here is factory class: 虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Pos* <span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Neg* <span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos* <span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Operation_Neg* <span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos* <span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Operation_Neg* <span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mut_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos* <span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Operation_Neg* <span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Factory</span>: <span class="keyword">public</span> Factory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos* <span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Operation_Neg* <span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    Add_Factory* p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation_Pos* p_pro = p_fac-&gt;<span class="built_in">CreateProduct_Pos</span>();</span><br><span class="line">    p_pro-&gt;val1 = a;</span><br><span class="line">    p_pro-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    Div_Factory* p_fac1 = <span class="keyword">new</span> <span class="built_in">Div_Factory</span>();</span><br><span class="line">    Operation_Neg* p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct_Neg</span>();</span><br><span class="line">    p_pro1-&gt;val1 = a;</span><br><span class="line">    p_pro1-&gt;val2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;<span class="comment">//-(3 / 5) = -0.6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p></li><li>简单工厂模式：一个工厂负责所有的产品创建，要创建某个产品时，需要明确告诉工厂要创建哪个具体产品，然后工厂再去创建，当需要新增产品时，<strong>需要去修改工厂类对应的源代码</strong>。</li><li>工厂方法模式：一个工厂只负责创建一个具体的产品，要创建某个产品时，只要找到对应的工厂即可，用该工厂创建。<strong>当需要新产品时，无需修改工厂源代码，而是新增对应的具体工厂即可</strong>。</li><li>抽象工厂模式：在简单工厂模式和工厂方法模式中，一个工厂族只能创建一类产品；<strong>当要新增产品类时，则需要新增工厂族。在抽象工厂中，一个工厂族能创建多个产品类。当要新增产品类时，只需新增对应的产品方法即可</strong>。(相对于工厂方法模式：这里相当于扩展了每个工厂能过创建多个类似的产品。)</li></ul><h1 id="观察者模式以及实现"><a href="#观察者模式以及实现" class="headerlink" title="观察者模式以及实现"></a>观察者模式以及实现</h1><h2 id="面试指数：⭐⭐⭐"><a href="#面试指数：⭐⭐⭐" class="headerlink" title="面试指数：⭐⭐⭐"></a>面试指数：⭐⭐⭐</h2><p><strong>观察者模式</strong>：定义一种一（被观察者）对多（观察者）的关系，让多个观察对象同时监听一个被观察对象，被观察对象发生状态变化时，会通知所有的观察对象，使他们能够更新自己的状态。<br>观察者模式中存在两种角色：</p><ul><li><strong>观察者</strong>：内部会包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li><li><strong>被观察者</strong>：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li><li><strong>应用场景</strong>：<ul><li>当一个对象的改变需要同时改变其他对象，且不知道有多少对象有待改变时，应该考虑使用观察者模式；</li><li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立的改变和复用。</li></ul></li><li><strong>实现方式</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;<span class="comment">//类的声明！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;<span class="comment">//观察者的名字</span></span><br><span class="line">    Subject* sub;<span class="comment">//被观察者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数：初始化 姓名和被观察者对象</span></span><br><span class="line">    <span class="built_in">Observer</span>(string name, Subject* sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sub = sub;<span class="comment">//构造函数来实例化sub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//虚函数，留给子类实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类：股票观察者（摸鱼）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockObserver</span>: <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//子类构造方法继承父类的实现逻辑</span></span><br><span class="line">    <span class="built_in">StockObserver</span>(string name, Subject* sub) : <span class="built_in">Observer</span>(name, sub) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;<span class="comment">//放到类外实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类：NBA观察者(摸鱼)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NBAObserver</span>: <span class="keyword">public</span> Observer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NBAObserver</span>(string name, Subject* sub) : <span class="built_in">Observer</span>(name, sub) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;<span class="comment">//放到类外实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被观察者基类 （内部存了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;Observer*&gt; observers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string action;<span class="comment">//被观察者对象的动作状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被观察者子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Secretary</span>: <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    <span class="comment">//添加观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除观察者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer* observer)</span> </span>&#123;</span><br><span class="line">        list&lt;Observer*&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*iter) == observer) &#123;</span><br><span class="line">                observers.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//被观察者通知观察者：调用观察者的方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list&lt;Observer*&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StockObserver::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;收到消息 &quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭股票，装作很认真的样子!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NBAObserver::update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;收到消息 &quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭NBA，装作很认真的样子!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject* dwq = <span class="keyword">new</span> <span class="built_in">Secretary</span>();<span class="comment">//实例化了一个被观察者所长</span></span><br><span class="line">    Observer* xs = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;xiaoshuai&quot;</span>, dwq);<span class="comment">//实例化了一个观察者，并且添加了对应的被观察对象</span></span><br><span class="line">    Observer* zy = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;zouyue&quot;</span>, dwq);<span class="comment">//同上</span></span><br><span class="line">    Observer* lm = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;limin&quot;</span>, dwq);<span class="comment">//同上</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所长添加</span></span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(xs);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(zy);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(lm);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;去吃饭了!&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;梁所长来了!&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h1><h2 id="面试指数：⭐⭐⭐-1"><a href="#面试指数：⭐⭐⭐-1" class="headerlink" title="面试指数：⭐⭐⭐"></a>面试指数：⭐⭐⭐</h2><p>《大话设计模式》一书中提到<code>24</code>种设计模式，这24种设计模式没必要面面俱到，但一定要深入了解其中的几种，最好结合自己在实际开发中的例子进行深入的了解。</p><p>设计模式有<code>6</code>大设计原则：</p><ol><li>单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。</li><li>开放封闭原则：软件实体可以扩展，但是不可修改。及面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li><li>里氏代换原则：一个软件实体如果使用的是一个基类，那么一定适用于派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li><li>依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象。即针对接口编程，不要针对实现编程。</li><li>迪米特原则：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另外一个类的某个方法的话，可以通过第三个类来转发这个调用。</li><li>接口隔离原则：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li></ol><p>设计模式分为三类：</p><ol><li>创造型模式：单例模式、工厂模式、建造者模式、原型模式</li><li>结构型模式：适配器模式、桥接模式、外观模式、组合模式、装饰模式、享元模式、代理模式</li><li>行为型模式： 责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。</li></ol><p>以下是常见的几种设计模式：</p><ol><li>单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点</li><li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式。<ul><li>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</li><li>工厂方法模式： 修正了简单工厂模式中不遵守开放封闭原则。把选择判断移动到了客户端实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li><li>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</li></ul></li><li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主体对象发生变化时，会通知所有的观察者，使他们能够更新自己。</li><li>装饰模式：动态的给一个对象添加一个额外的职责，就增加功能来说，装饰模式比生成派生类更灵活。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 面试突破 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成长日记</title>
      <link href="/2023/08/16/%E7%9B%AE%E6%A0%87%E6%B8%85%E5%8D%95/"/>
      <url>/2023/08/16/%E7%9B%AE%E6%A0%87%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<div class="note primary simple"><ul><li><div class='checkbox green'><input type="checkbox" />          <p>拥有健康的身体</p>          </div></li><li><div class='checkbox green'><input type="checkbox" />          <p>基础算法学习</p>          </div></li><li><div class='checkbox green'><input type="checkbox" />          <p>剑指offer3刷</p>          </div></li><li><div class='checkbox green'><input type="checkbox" />          <p>牛客项目</p>          </div></li><li><div class='checkbox green'><input type="checkbox" />          <p>过年前看完电影50部</p>          </div></li><li><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>          <p>leetcode竞赛分达到1500+</p>          </div><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/Horn-JoJo/pic_bed@main/2023/07image-20231107224347319.png"/></div></div></li><li><div class='checkbox yellow'><input type="checkbox" />          <p>leetcode竞赛分达到1600+</p>          </div></li></ul></div> <div class="timeline  red"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>11月：每个人都是孤独的! 所以要心怀感恩</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-29 第一周总结与规划</p></div></div><div class='timeline-item-content'><ul><li>算法：小有成就，终于上1500了。继续加油，跟紧灵神，稳上大分！！！先刷基础算法精讲。</li><li>项目：还没能有一个熟练的项目，后续加把劲！！！这个要重视起来</li><li>剑指offer+面试突破再刷！！！</li><li>开启实践！！！每周至少一面。</li></ul></div></div></div><div class="timeline green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>要学会接收不同的意见</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-29 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>周赛307Q1Q2+春招题目n题</li><li>剑指offer三刷  螺旋矩阵</li></ul></li><li>健康</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-28 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>79双周赛Q3学习</li><li>剑指offer三刷  队列的最大值</li></ul></li><li>健康<ul><li>坚持keep的第61天</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-27 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>二分学习</li><li>剑指offer三刷 滑动窗口最大值</li></ul></li><li>健康<ul><li>坚持keep的第60天</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-26 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>二分学习</li><li>剑指offer三刷 优化最小栈</li></ul></li><li>健康<ul><li>坚持keep的第59天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-25 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>剑指offer三刷, 完成栈与队列2题</li></ul></li><li>健康<ul><li>坚持keep的第58天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>练字10min</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-24 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>剑指offer三刷, 完结双指针专题</li><li>周赛上分了！！！</li></ul></li><li>健康</li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-22 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>acwing学习了floyd算法+复习快排和归并排序+学习css</li><li>面试突破学习到volatile</li><li>剑指offer三刷到<code>复杂链表的复制</code></li></ul></li><li>健康<ul><li>坚持keep的第57天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>练字10min</li></ul></li><li>娱乐<ul><li>咒术回战2p</li></ul></li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-21 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>学习筛质数</li><li>338周赛Q1Q2Q4学习</li><li>面试突破学习const关键字</li></ul></li><li>健康</li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>练字10min</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-20 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题</li><li>牛客知识库打卡</li></ul></li><li>健康</li></ol><ul><li>keep的第56天</li></ul><ol><li>社交</li><li>认知<ul><li>电影：心灵捕手</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-19 学习</p></div></div><div class='timeline-item-content'><ol><li><p>学习</p><ul><li>完成每日一题+学习树形dp</li><li>牛客知识库打卡</li><li>牛客项目-gdb学习</li><li>复习和学习图论spfa算法</li></ul></li><li><p>健康</p></li></ol><ul><li>keep的第55天</li></ul><ol><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>更新日记</li><li>早起洗漱</li><li>练字10min</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-18 学习</p></div></div><div class='timeline-item-content'><ol><li>学习<ul><li>完成每日一题+学习树形dp</li><li>牛客知识库打卡</li><li>复习图论djkstra,bellman_ford,spfa算法</li><li>剑指offer<code>反转链表</code></li></ul></li><li>健康</li></ol><ul><li>keep的第54天</li></ul><ol><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>更新日记</li><li>早起洗漱</li><li>练字10min</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-17 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>复习了剑指offer<code>从尾巴到头打印链表</code>、<code>反转链表</code></li><li>Q4学习</li><li>周赛学习了Q1Q2</li><li>html标签学习完结+bellman_ford算法学习</li></ul></li><li>健康</li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-16 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>学习dijkstra算法学习+学习了html标签</li></ul></li><li>健康</li><li>社交</li><li>认知</li><li>习惯</li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-15 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>复习了剑指offer<code>将字符串转化为数字</code>使用状态机来解决</li><li>复习了acwing单链表实现+有向图的拓扑序列+学习了了html标签</li></ul></li><li>健康<ul><li>keep第53天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐<ul><li>呪术廻戦看了2集</li></ul></li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-14 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题+158周赛Q1Q2</li><li>牛客知识库打卡</li><li>复习了剑指offer<code>将字符串转化为数字</code></li><li></li></ul></li><li>健康<ul><li>keep第52天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-13 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题+337周赛Q1Q2</li><li>牛客知识库打卡并且学习了项目makefile</li><li>acwing复习了浮点型二分查找</li></ul></li><li>健康<ul><li>keep第51天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-12 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题+周赛27Q1Q2Q3</li><li>牛客知识库打卡并且学习了项目，库的制作完结</li><li>acwing复习了二分查找</li><li>面试突破学习完static章节</li></ul></li><li>健康<ul><li>keep第50天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-11 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡并且学习了项目</li><li>acwing 复习了逆序对的数量</li><li>剑指offer复习表示数值的字符串</li><li>面试突破继续看static章节</li></ul></li><li>健康<ul><li>keep第49天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li><strong> 多放松眼睛</strong></li><li><strong>多增加点思维认知学习时间</strong> </li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-10 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>acwing 复习了归并排序+差分数组</li><li>参加周赛并掌握了前三题</li></ul></li><li>健康<ul><li>keep第48天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li><li>收拾房间</li></ul></li><li>娱乐<ul><li>三集魔禁</li></ul></li><li>提升</li><li>改进<ul><li>多放松眼睛</li><li>多增加点思维认知学习时间</li></ul></li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-09 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>牛客项目学习到静态库使用</li></ul></li><li>健康<ul><li>休息一天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li><li>早起洗漱</li></ul></li><li>娱乐<ul><li>两集魔禁 + 咒术回战</li></ul></li><li>提升</li><li>改进</li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li><li>又玩了了游戏！！！</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-08 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成Q1Q2Q3(343)</li><li>牛客知识库打卡</li><li>牛客项目学习到静态库制作</li><li>C++面试突破：C和C++static的作用</li><li>acwing复习到第k个数</li><li>剑指offer <code>从头到尾打印链表</code>过了</li></ul></li><li>健康<ul><li>坚持keep第47天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li></ul></li><li>娱乐<ul><li>两集魔禁 + 咒术回战</li></ul></li><li>提升</li><li>改进</li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-07 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成Q1Q2</li><li>大疆面试第二题</li><li>牛客知识库打卡</li><li>C++面试突破 c++17新特性</li><li>acwing复习快速排序</li><li>剑指offer从尾到头打印链表</li></ul></li><li>健康<ul><li>坚持keep第46天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li></ul></li><li>娱乐<ul><li>两集魔禁</li></ul></li><li>提升</li><li>改进</li><li>坏习惯<ul><li>睁眼刷b站</li><li>边学习边看视频</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-06 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成Q1Q2</li><li>大疆面试题第一题+第二题的对应的周赛第一题</li><li>牛客知识库打卡</li></ul></li><li>健康</li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li></ul></li><li>娱乐</li><li>提升</li><li>改进</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-05 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer三刷两题</li><li>面试突破c++新特性到<strong>初始化列表</strong></li></ul></li><li>健康<ul><li>坚持keep的第45天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>每日练字10min</li><li>更新日记</li></ul></li><li>娱乐</li><li>提升</li><li>改进<ul><li>明天在习惯上添加一个acwing基础代码练习</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-04 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>剑指offer二刷完结</li></ul></li><li>健康<ul><li>坚持keep的第44天</li></ul></li><li>社交</li><li>认知<ul><li>教父：要对自己的家人有责任感</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li><li>更新日记</li></ul></li><li>娱乐</li><li>提升</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-03 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛Q1Q2</li><li>周赛Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>圆圈中最后剩下的数字</code></li><li>面试突破：编译与链接-&gt;和include的区别</li></ul></li><li>健康<ul><li>坚持keep的第43天</li></ul></li><li>社交</li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li><li>更新日记</li></ul></li><li>娱乐<ul><li>玩游戏玩了n把（不玩了额）</li></ul></li><li>提升</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-02 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>和为s的连续正数序列</code></li><li>面试突破：智能指针的创建和应用-&gt;智能指针的创建</li></ul></li><li>健康<ul><li>坚持keep的第42天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了3把</li></ul></li><li>提升<ul><li>更新博客</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-09-01 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>剪绳子I、II</code></li><li>面试突破：c++内存管理-&gt;内存对齐</li><li>找到了github的awesome的C++项目</li></ul></li><li>健康<ul><li>坚持keep的第41天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了3把</li></ul></li><li>提升<ul><li>更新博客</li></ul></li></ol></div></div></div><hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>慢慢来就会快</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-31 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>数组中出现次数超过一半的数字</code></li></ul></li><li>健康<ul><li>坚持keep的第40天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知<ul><li>看了影评血观音，感悟就是你怎么对待别人，别人会怎么对待你。</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了5把</li></ul></li><li>提升<ul><li>更新博客</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-30 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛39场Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>数组中数字出现的次数II</code></li></ul></li><li>健康<ul><li>坚持keep的第39天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了n把。。。</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-29 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成周赛81场Q1Q2</li><li>牛客知识库打卡</li><li>剑指offer-<code>数组中数字出现的次数</code></li></ul></li><li>健康<ul><li>坚持keep的第38天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字5min</li><li>练习键盘打字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了4把</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-28 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成每日一题</li><li>牛客知识库打卡</li><li>剑指offer-<code>二进制中1的个数</code></li></ul></li><li>健康<ul><li>坚持keep的第37天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知<ul><li>学习了《富有的习惯》书评</li></ul></li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li><li>每日练字5min</li><li>练习键盘打字10min</li></ul></li><li>娱乐<ul><li>玩游戏玩了三个小时</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-27 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运IO与进程同步（完结但是还是不懂原理）</li></ul></li><li>健康<ul><li>坚持keep的第36天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-26 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运IO与进程同步（没有搬完）</li></ul></li><li>健康<ul><li>坚持keep的第35天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-25 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运IO与进程同步（没有搬完）</li></ul></li><li>健康<ul><li>坚持keep的第34天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>习惯<ul><li>早起放歌</li><li>早起洗漱</li></ul></li><li>娱乐<ul><li>看了咒术回战2</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-24 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运sizeof和strlen的区别</li></ul></li><li>健康<ul><li>坚持keep的第33天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>娱乐</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-23 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运设计模式之观察者模式以及常见设计者模式</li></ul></li><li>健康<ul><li>坚持keep的第32天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知-人与人之间的差距其实是执行力！！！</li><li>娱乐</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-22 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li><code>礼物的最大价值</code> 和 <code>把数字翻译成字符串</code>Rust实现完结</li><li>完成今天周赛的前两题</li><li>牛客知识库打卡</li><li>学习并搬运设计模式之工厂模式</li></ul></li><li>健康<ul><li>坚持keep的第31天</li></ul></li><li>社交<ul><li>和盆友聊天</li></ul></li><li>认知</li><li>娱乐</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-21 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li><code>股票的最大利润</code>Rust实现完结</li><li>力扣周赛只做了一题。</li><li>牛客知识库打卡</li><li>学习环形缓冲区</li></ul></li><li>健康<ul><li>坚持keep的第30天</li></ul></li><li>社交<ul><li>跟盆友聊天。</li></ul></li><li>认知<ul><li>无</li></ul></li><li>娱乐<ul><li>看了雾山五行，非常震撼！！！</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-20 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li><code>连续子数组的最大和</code>Rust实现完结</li><li>力扣周赛只做了一题。</li><li>牛客知识库打卡</li></ul></li></ol><ul><li>今天摆了大烂。。。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-19 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li><code>股票的最大利润</code> + <code>不用加减乘除做加法</code>问题Rust实现完结</li><li>设计模式学习-单例模式，明天把数据库加上！</li><li>牛客知识库打卡</li><li>牛客项目linux高并发服务器学习</li><li>跟盆友讨论环形缓冲区</li></ul></li><li>健康<ul><li>坚持keep的第29天</li></ul></li><li>社交<ul><li>跟盆友聊天</li></ul></li><li>认知<ul><li>无，明天看一部电影</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-18 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li><code>青蛙跳台阶</code>问题Rust实现完结</li><li>算法学习八皇后问题 + 八数码</li><li>环形缓冲区进一步了解，是操作系统中一种重要的数据结构</li><li>明天开始额外加数据库学习 + 设计模式学习 + 牛客知识库打卡</li></ul></li><li>健康<ul><li>坚持keep的第28天</li></ul></li><li>社交<ul><li>跟盆友聊天</li></ul></li><li>认知<ul><li>看了稚晖君的智元机器人发布会</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-17 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>剑指offer <code>斐波那契数列</code> rust版完结 + <code>青蛙跳台阶</code>问题Rust实现进行中</li><li>初步了解环形缓存缓冲区的本质，以及应用场景。</li><li>打字练习</li></ul></li><li>健康<ul><li>坚持keep的第27天</li></ul></li><li>社交<ul><li>跟盆友聊天</li></ul></li><li>认知<ul><li>看了一会小米演讲，收获了一个启发。(明天继续看)<ul><li><strong>很多事情和遇到的问题都是别人经历或者解决过的。这时不要一个人单打独斗，需要别人的帮助！！！！</strong></li></ul></li></ul></li><li>反思<ul><li>我效率慢吗？<ul><li>上午做了啥？<ul><li>keep锻炼（8点多醒，但是耍手机刷了很多才开始动一直拖到了9点半左右）</li><li>剑指offer  二刷学习，上午没有完成昨天的Rust翻译</li></ul></li><li>中午做了啥？<ul><li>跟盆友聊了天</li><li>睡了午觉</li><li>看小米演讲（看了一会，并没有看完）</li></ul></li><li>下午做了啥？<ul><li>完成了昨天的剑指offer题目 + 今天的<code>青蛙跳台阶</code>问题二刷</li></ul></li><li>晚上做了啥？<ul><li>今天的<code>青蛙跳台阶</code>问题二刷</li><li>环境缓冲区学习。</li></ul></li></ul></li><li>回答：慢<ul><li>一件事情拖了很久</li><li>碎片时间莫名其妙的就没了，刷视频去了？？？！！！（要注意关注自己的手机了）</li></ul></li><li>措施：<ul><li><strong>早上不刷视频，直接起来运动</strong></li><li><strong>跟盆友聊天时间固定在吃饭或者晚上休息前1小时</strong></li></ul></li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-16 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>编译通过了一个简单C++项目并上传到了自己的仓库中。</li><li>每日一题 + 剑指offer <code>斐波那契数列</code> rust学习</li><li>明天学习哈环形缓冲区 + 算法 + 设计模式</li></ul></li><li>健康<ul><li>坚持keep的第26天</li></ul></li><li>社交<ul><li>跟盆友聊天</li></ul></li><li>认知<ul><li>无学习(明天学习点相关的)</li></ul></li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2023-08-15 找工作中</p></div></div><div class='timeline-item-content'><ol><li>找工作<ul><li>学习了柔性数组。</li><li>初步了解了nginx。</li></ul></li><li>健康<ul><li>坚持keep的第25天</li></ul></li><li>社交<ul><li>跟盆友聊天</li></ul></li><li>认知<ul><li>无学习</li></ul></li></ol></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 目标清单 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ngnix初识</title>
      <link href="/2023/08/15/ngnix/"/>
      <url>/2023/08/15/ngnix/</url>
      
        <content type="html"><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><ul><li>web服务器、反向代理服务器，通过代理的方式，使得所有的服务器公用一个公网IP, 并且能响应请求。外部都是访问同一个公网IP, 内部的是一个子网IP。这个代理的结点，就是nginx。</li></ul><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>正/反向代理<ul><li>正向代理：自己浏览器被vpn代理了</li><li>反向代理：服务器被代理了</li></ul></li><li>负载均衡：作为多个服务器机器的总管，能够根据不同机器的运算能力分配合适的任务。</li><li>动静分离：动态数据和静态数据组织起来，发送给浏览器</li></ul><h1 id="nginx与apache的区别"><a href="#nginx与apache的区别" class="headerlink" title="nginx与apache的区别"></a>nginx与apache的区别</h1><ul><li>apache先于nginx出现特点是用户一个请求，服务器就会创建一个线程去处理。并发量不会很高，做不到并发量超过一万C1K。select/poll技术</li><li>nginx架构性能都比apache好。使用了epoll技术.C1M（百万并发量）</li></ul><h1 id="nginx工程上的实践"><a href="#nginx工程上的实践" class="headerlink" title="nginx工程上的实践"></a>nginx工程上的实践</h1><ol><li>起到转发的作用<br><img src="https://article.biliimg.com/bfs/article/e4775a28e665b8f74664dab2394f7511bd6839f5.png" alt="image-20230815221558967"></li></ol><ul><li>为每个请求加上时间戳。GET/POST/DELETE/HEAD， 在nginx上面加上一个模块</li><li>为每一个请求加上MD5, 在nginx上做。</li><li>为每个网页<div>加上一个广告。在nginx做成一个广告的模块</li></ul><p>现实问题：公司老板得罪了自己手下的工程师，工程师直到了自己服务器的接口。工程师攻击公司的服务器，包了几个网吧，不断的发送http请求，使得真实的用户访问时就很慢或者访问不了。这时候你会如何处理？</p><p>解决办法：在nginx上处理，设定一个限制，规定一个IP发送的请求，规定每1s中只响应一次。</p><p><strong>后续还需学习：模块开发，运维部署，nginx源码学习</strong></p>]]></content>
      
      
      <categories>
          
          <category> web服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>柔性数组</title>
      <link href="/2023/08/15/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/15/%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>柔性数组（flexible array member）, 也叫“伸缩数组”或“不定长数组”，是一种c语言中常用的技术，用于结构体的末尾声明一个数组成员，该数组成员的大小可以在运行时动态分配和调整，而不需要在编译时就确定大小。</p></blockquote><h1 id="为什么会出现柔性数组？"><a href="#为什么会出现柔性数组？" class="headerlink" title="为什么会出现柔性数组？"></a>为什么会出现柔性数组？</h1><blockquote><p>传统上，c语言中的数组大小必须在编译时就已知，就在一些情况下会限制数据结构的灵活性，特别是在需要动态调整的大小的情况下。<strong>柔性数组通过结构体末尾声明一个数组成员来解决这个问题，从而在结构体内部创建一个变长的数据缓冲区。</strong></p></blockquote><h1 id="柔性数组的特点"><a href="#柔性数组的特点" class="headerlink" title="柔性数组的特点"></a>柔性数组的特点</h1><ol><li>声明：柔性数组<strong>只能用于结构体中</strong>，并且<strong>必须是结构体的最后一个成员</strong></li><li>分配：柔性数组的内存分配通常是动态内存分配函数(如<code>malloc</code>)在运行时进行的，根据需要分配适当大小的内存空间。</li><li>使用：柔性数组可以向普通数组一样使用，通过索引访问数组元素。访问数组元素时，可以使用结构体的起始地址加上柔性数组的偏移量来计算内存位置。</li><li>大小：柔性数组的大小是在运行时决定的，因此可以根据需要调整数组的大小。</li></ol><p><code>注意：</code></p><ul><li><strong>未实例化的含有柔性数组的结构体大小=除了柔性数组的其他字节大小之和。如果除了柔性数组成员外，没有其他成员，则sizeof(结构体) = 0.</strong></li><li><strong>实例化柔性数组对应的大小需要手动计算（包含类的部分+柔性数组的部分)，而不能用sizeof来计算。</strong></li><li><strong>柔性数组只能用于动态分配，因为需要运行时分配额外的内存来存储数组数据。在栈上或静态内存分配中，柔性数组是不允许的。</strong></li></ul><p><strong>优势：在不浪费空间的情况下实现变长数据结构。这对于需要存储不定数量的元素，但又不想预先分配足够大的内存空间的情况非常有用。</strong></p><p>示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlexArrayStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> data[];</span><br><span class="line">&#125;FlexArray;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arrLength = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//实例化的包含柔性数组的结构体大小需要手动计算大小。不能用sizeof来计算！！！</span></span><br><span class="line">    FlexArray* myArray = (FlexArray*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FlexArray) + arrLength * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != myArray) &#123;</span><br><span class="line">        myArray -&gt;length = arrLength;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myArray-&gt;length;  i++) &#123;</span><br><span class="line">            myArray-&gt;data[i] = i * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; myArray-&gt;length;  i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myArray[%d] = %d\n&quot;</span>, i, myArray-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(myArray);</span><br><span class="line">    myArray = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> nginx内存池 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节（内存）对齐</title>
      <link href="/2023/08/13/%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/"/>
      <url>/2023/08/13/%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、一般字节对齐"><a href="#一、一般字节对齐" class="headerlink" title="一、一般字节对齐"></a>一、一般字节对齐</h1><blockquote><p>各个数据类型需要按照一定规则存放到存储单元中，相邻的数据并不一定是连续的紧紧挨在一起的，两个object之间可能会有空隙。这个空隙是padding。**<br>变量存的起始地址必须具备某种特性-‘对齐’，如4字节的int类型的起始地址，应该位于4字节的边界上，即起始地址能被4整除。</p></blockquote><p><strong>为什么需要字节对齐?</strong></p><ul><li>不同硬件平台的对存储空间的处理上存在不同。</li><li>尽可能保证一次取数的完整性，以便提升访问数据性能。</li></ul><p><strong>一般规则</strong></p><ul><li>补充(自然对齐与非自然对齐)<ul><li>自然对齐：对于标量类型，如char，int, 指针等等，其alignof等于sizeof，称作自然对齐。</li><li>非自然对齐<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">alignof</span>(arr) != <span class="built_in">sizeof</span>(arr);<span class="comment">//前者为4字节，后者为40字节</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ol><li><strong>填充padding, 使得保证下一个数据类型T的起始地址能够整除alignof(T): 换句话说，起始位置必须是alignof(T)的整数倍。</strong></li><li><strong>自然对齐下，结构体的alignment等于其成员中最大的alignment。（最大的alignment在不同机器同一个类型取值可能不同）</strong></li><li><strong>结构体的sizeof等于其成员中最大的alignment的整数倍(这个通常是用来确定最后一个元素的字节数大小)。</strong></li></ol><h2 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> c;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line"><span class="type">short</span> b;<span class="number">2</span></span><br><span class="line"><span class="type">bool</span> a;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>32位：6字节；64位：6字节</code><br><strong>解释：满足每个元素的起始位置是当前元素的aligement的整数倍；满足结构体的sizeof等于其成员中最大的aligement的整数倍-这是里2的整数倍</strong></p><h2 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> c;<span class="number">1</span>-&gt;<span class="number">4</span></span><br><span class="line"><span class="type">int</span> b;<span class="number">4</span></span><br><span class="line"><span class="type">bool</span> a;<span class="number">1</span>-&gt;<span class="number">4</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>32位：12字节，64位：12字节</code></p><p><strong>解释：满足每个元素的起始位置是当前元素的aligement的整数倍；满足结构体的sizeof等于其成员中最大的aligement的整数倍-这是里4的整数倍</strong></p><h2 id="eg3"><a href="#eg3" class="headerlink" title="eg3"></a>eg3</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> c;<span class="comment">//1-&gt;4  保证与后面的int类型数据对齐(保证数据下一个数据类型起始位置是对应数据类型的整数倍)</span></span><br><span class="line"><span class="type">int</span> b;<span class="comment">//4 </span></span><br><span class="line"><span class="type">bool</span> a;<span class="comment">//1-&gt;4 (1-&gt;8)</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d;<span class="comment">//8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>32位：20字节；64位：24字节</code><br><strong>解释：满足每个元素的起始位置是当前元素的aligement的整数倍；满足结构体的sizeof等于其成员中最大的aligement的整数倍（32位 alignof(long long） = 4;64位 alignof(long long) = 8)</strong></p><h1 id="二、-含有位域的字节对齐"><a href="#二、-含有位域的字节对齐" class="headerlink" title="二、 含有位域的字节对齐"></a>二、 含有位域的字节对齐</h1><ul><li><p><strong>MSVC: 需要满足每个类型的起始位置都是对应类型的alignment的整数倍</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_field</span> &#123;</span><br><span class="line">    <span class="type">short</span> a;<span class="comment">//MSVC: 2字节</span></span><br><span class="line">    <span class="type">char</span> b;<span class="comment">//MSVC: 需要字节对齐，保证下面int c的起始位置是alignof(int)的整数倍，需要填充1字节</span></span><br><span class="line">    <span class="type">int</span> c:<span class="number">1</span>;<span class="comment">//MSVC: 4字节，使用1位，剩余31位</span></span><br><span class="line">    <span class="type">char</span> d:<span class="number">4</span>;<span class="comment">//MSVC: 需要字节对齐，保证下面short e的起始位置是alignof(short)的整数倍, 需要填充1字节 使用4位，剩余12位</span></span><br><span class="line">    <span class="type">short</span> e:<span class="number">7</span>;<span class="comment">//MSVC: 2字节 </span></span><br><span class="line">    <span class="comment">//MAVC: 已经是alignof(int)的整数倍</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>clang|gcc: 在存储的时候不需要满足每个类型起始位置的是其对应的alignment的整数倍。只需要在最后补充字节保证结构体是最大alignment的整数倍</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_field1</span> &#123;</span><br><span class="line">    <span class="type">short</span> a;<span class="comment">//clang|gcc: 2字节</span></span><br><span class="line">    <span class="type">char</span> b;<span class="comment">//clang|gcc: 1字节，不用字节对齐</span></span><br><span class="line">    <span class="type">int</span> c:<span class="number">1</span>;<span class="comment">//clang|gcc: 分配1字节，使用了1比特位，剩余7比特位。</span></span><br><span class="line">    <span class="type">char</span> d:<span class="number">4</span>;<span class="comment">//clang|gcc: 上述分配空间剩余的比特位能够存储下来4比特位，剩余3比特位</span></span><br><span class="line">    <span class="type">short</span> e:<span class="number">7</span>;<span class="comment">//clang|gcc：上述剩余的比特位不能装下7个比特位，因此开辟新的一字节来存储，使用7比特位，剩余1比特位</span></span><br><span class="line">    <span class="comment">//2 + 1 + 1 + 1 = 5字节，为了保证结构体大小是alignof(int)的整数倍，因此补充3字节对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="三、类的字节对齐"><a href="#三、类的字节对齐" class="headerlink" title="三、类的字节对齐"></a>三、类的字节对齐</h1><ul><li><strong>空类：大小为1字节</strong></li><li><strong>含有多个基类的子类的字节对齐：按照继承的顺序依次罗列出对应类的成员，然后按照字节对齐规则去计算</strong></li></ul><h2 id="eg4"><a href="#eg4" class="headerlink" title="eg4"></a>eg4</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> c;<span class="comment">//1-&gt;4 保证是int的起始地址是alignof(int)的整数倍</span></span><br><span class="line">    <span class="type">int</span> a;<span class="comment">//4</span></span><br><span class="line">    <span class="type">bool</span> b;<span class="comment">//1-&gt;4 保证是最大alignof(int)的整数倍</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//按照上述一的方式进行分析即可：均为12字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C类字节大小 = A的成员字节大小+C的成员字节大小(也需要遵循字节对齐原则)</span></span><br><span class="line"><span class="comment">//A的成员：没有成员就不算字节大小</span></span><br><span class="line"><span class="comment">//C的自己成员：虚函数表对应的vptr,32位：字节；64位：8字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//32位：4字节；64位：8字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;</span><br><span class="line"><span class="comment">//D类字节大小 = B类成员大小+ C类成员大小(A类型成员大小+C类自身成员大小)</span></span><br><span class="line"><span class="comment">//按照顺序列出成员，按照字节对齐的方式来计算</span></span><br><span class="line">D&#123;</span><br><span class="line"><span class="comment">//B类的成员</span></span><br><span class="line"><span class="type">bool</span> c;<span class="comment">//1-&gt;4</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//4</span></span><br><span class="line"><span class="type">bool</span> b;</span><br><span class="line"><span class="comment">//32位机器 保证下一个指针的地址是alignof(指针)整数倍：1-&gt;4</span></span><br><span class="line"><span class="comment">//64位机器 保证下一个指针的地址是alignof(指针)整数倍：1-&gt;8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//C类自己的</span></span><br><span class="line"><span class="comment">//32位：4字节；64位：8字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当为32位机器时，大小为4 + 4 + 4 + 4 = 16字节 按照最大的alignof(指针)的整数倍对齐</span></span><br><span class="line"><span class="comment">//当为64位机器时，大小为4 + 4 + 8 + 8 = 24字节 按照最大的alignof(指针)的整数倍对齐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;<span class="comment">// 1 1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;<span class="comment">// 12 12</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl;<span class="comment">// 4 8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; endl;<span class="comment">// 16 24</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、静态成员变量不计算类所占内存的大小"><a href="#三、静态成员变量不计算类所占内存的大小" class="headerlink" title="三、静态成员变量不计算类所占内存的大小"></a>三、静态成员变量不计算类所占内存的大小</h1><ul><li><strong>由于类的静态成员变量编译时被分配到静态/全局区，静态成员变量是属于类的，所有对象共有一份，不计入类的内存空间</strong></li></ul><h1 id="四、函数不占存储空间-虚函数之外"><a href="#四、函数不占存储空间-虚函数之外" class="headerlink" title="四、函数不占存储空间(虚函数之外)"></a>四、函数不占存储空间(虚函数之外)</h1><blockquote><p>除了虚函数之外！！！并且不管虚函数有多少个，都只需要一个指针(维护虚函数表的指针)就够了！！！）<br>C++中成员函数和非成员函数都是放在代码区的，其中一般成员函数，友元函数，内联函数，以及静态成员函数都不计入类的存储空间</p></blockquote><p><strong>原因：编译系统中，数据和函数是分开存放的，函数放在代码区，数据主要放在栈区或者堆区，静态/全局区以及常量区), 实例化不同对象时，只给数据分配空间，各个对象调用函数时都能跳转到（内联函数除外）找到函数在代码区的入口执行。可以节省拷贝多份代码的空间.</strong></p><h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><ul><li>构造函数没有返回值，包括void.</li><li>可以定义多个构造函数，称为构造函数的重载</li><li>构造函数可以在对象创建时自动执行，无需显示调用</li><li>构造函数可以初始化成员变量、分配资源等初始化操作</li><li>默认构造函数是在没有显示定义构造函数时由编译器提供的</li><li>如果定义了任何构造函数，编译器将不再提供默认构造函数</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><blockquote><p>特殊的成员函数，用在对象销毁（生命周期结束）时执行清理操作，在销毁对象时自动被调用。（避免资源泄漏和内存泄漏等问题）<br>格式：~+类名<br>如果没有显示定义析构函数，编译器默认提供一个析构函数，但如果你定义了任何一个析构函数，编译器将不再提供默认析构函数。</p></blockquote><ul><li>析构函数没有返回值，包括void</li><li>可以定义一个析构函数，不能重载多个析构函数</li><li>析构函数在对象销毁时自动执行，无需显示调用</li><li>析构函数用于释放资源，清理操作等。</li><li>默认析构函数是在没有显示定义析构函数时由编译器提供的</li><li>如果定义了析构函数，编译器将不再提供默认的析构函数</li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote><p>虚函数是C++中实现多态性的关键机制之一。它允许在基类中声明一个函数为虚函数，然后在派生类中。重写（覆盖）这个虚函数。通过这种方式，当通过基类的指针或者引用调用虚函数时，实际上会根据对象的实际类型（运行时类型）来调用相应的派生类函数，实现了多态性。</p></blockquote><ul><li>要声明一个虚函数，需要在虚函数声明前加上·virtual·关键字。派生类中如果要重写基类中的虚函数，需要在函数前也加上<code>virtual</code>关键字，并保持函数签名一致。        </li><li>声明虚函数需要在函数声明前加上<code>virtual</code>关键字。</li><li>派生类中重要基类的虚函数，需要保持函数签名一致，并在函数前也加上<code>virtual</code>关键字(这是可选的，但建议显示以提高代码可读性)</li><li>通过基类的指针或引用调用虚函数时，会根据对象的实际类型来调用相应的派生类函数，这是运行时动态绑定的结果。</li><li>虚函数允许我们在多态的情况下更灵活地处理对象，提高代码的可扩展性和可维护性。</li></ul><h2 id="友元函数："><a href="#友元函数：" class="headerlink" title="友元函数："></a>友元函数：</h2><ul><li>在类内部中实现函数声明并且参数本类对象来进行传递</li><li>在类外中实现对类的操作的操作逻辑（可以修改私有变量和调用私有函数！！！）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello from Myclass!: a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="comment">//声明一个友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Myclass&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义友元函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Myclass&amp; obj)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello form print() function!&quot;</span> &lt;&lt; endl;</span><br><span class="line">obj.a = <span class="number">666</span>;<span class="comment">//修改对象的私有变量</span></span><br><span class="line">obj.<span class="built_in">print</span>();<span class="comment">//调用对象的私有方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Myclass obj;</span><br><span class="line"><span class="comment">//obj.print();私有成员函数不能直接访问</span></span><br><span class="line"><span class="built_in">print</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><blockquote><p>内联函数的逻辑会在编译时将函数内部的逻辑被复制到调用位置，直接进行计算，而不是通过函数调用<br>内联函数（声明和定义都要加inline）也是存放在代码区。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(<span class="number">12</span>, <span class="number">34</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><ul><li>定义在类内部的、不依赖于类的任何对象的函数。</li><li>它们可以在不创建类对象的情况下调用，通常用于表示类的操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello C++ world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Myclass::<span class="built_in">printMessage</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、自定义对齐字节大小"><a href="#五、自定义对齐字节大小" class="headerlink" title="五、自定义对齐字节大小"></a>五、自定义对齐字节大小</h1><ul><li>完全可以按照第字节对齐规则的方式去推出来！！！<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> pack(16)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//对齐系数：       1    4 + 8 + 1 = 13</span></span><br><span class="line">    <span class="comment">//对齐系数:        2    4 + 8 + 2 = 14</span></span><br><span class="line">    <span class="comment">//x86默认对齐系数：4    4 + 8 + 4 = 16</span></span><br><span class="line">    <span class="comment">//x64默认对齐系数：8    8 + 8 + 8 = 24</span></span><br><span class="line">    <span class="comment">//对齐系数：       16   8 + 8 + 8 = 24 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx内存池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节对齐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建教程(1)</title>
      <link href="/2023/08/08/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-1/"/>
      <url>/2023/08/08/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ul><li><p>github账号</p></li><li><p>node</p></li><li><p>git</p></li><li><p>hexo</p></li><li><p>文本编辑器</p></li></ul><h2 id="github账号注册与创建仓库"><a href="#github账号注册与创建仓库" class="headerlink" title="github账号注册与创建仓库"></a>github账号注册与创建仓库</h2><p><a href="https://github.com/">GitHub</a></p><p><strong>注册完成后，点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库</strong></p><h2 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h2><p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p><img src="https://article.biliimg.com/bfs/article/756596c14731643480d8d2fd9d4c57d4eb4174d9.png" alt="image-20230807111622221"></p><ul><li><p>验证安装是否成功</p><ul><li>win+r：输入node -v进行验证，如果出现版本信息则安装成功</li></ul></li><li><p>npm换源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ul><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p><a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p><p><strong>配置用户名和邮箱</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p><code>git config -l</code></p><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="文本编辑器-Vscode"><a href="#文本编辑器-Vscode" class="headerlink" title="文本编辑器(Vscode)"></a>文本编辑器(Vscode)</h2><h1 id="git与github相连接"><a href="#git与github相连接" class="headerlink" title="git与github相连接"></a>git与github相连接</h1><p>指向以下命令生成ssh公钥，此公钥用于自己的git能够连接到自己的github账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后打开c盘用户文件夹下的.ssh文件夹，会看到id_rsa.pub</p><p><img src="https://bu.dusays.com/2022/05/14/627e87126fc59.png" alt="img"></p><p>记事本打开公钥（id_rsa.pub），复制里面的内容，然后开始在github中配置ssh密钥</p><p>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏</p><p>测试连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h1 id="初始化Hexo项目"><a href="#初始化Hexo项目" class="headerlink" title="初始化Hexo项目"></a>初始化Hexo项目</h1><p>在博客路径下指向命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog(项目名)</span><br></pre></td></tr></table></figure><p>进入博客目录安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>博客目录说明</p><p>[node_modules]：依赖包</p><p>[scaffolds]：生成文章的一写模板</p><p>[source]：用来存放文章</p><p>[themes]：主题</p><p>[.npmignore]：发布时忽略的文件</p><p>[_config.landscape.yml]：主题的配置文件</p><p>[config.yml]：博客的配置文件</p><p>[package.json]：项目名称、描述、版本、运行和开发等信息 </p><p>项目启动：<code>hexo s</code></p><p>查看本地服务博客：<a href="http://localhost:4000/">http://localhost:4000/</a> ，如果出现以下效果，则说明博客构建成功了</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>​    挂载本地博客到github pages上</p><ol><li><p>安装 hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改_config.yml文件</p><p>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:misaka20005/misaka20005.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy  // VSCODE终端</span><br></pre></td></tr></table></figure><ul><li>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</li><li>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</li><li>hexo deploy：部署文章，可以用<code>hexo d</code>缩写</li></ul><p>如果出现了deploy done,则说明部署成功了。</p><p>然后过一段时间，再去访问<a href="https://misaka20005.github.io，就可以看到博客内容了。">https://misaka20005.github.io，就可以看到博客内容了。</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2023/07/30/%E5%89%91%E6%8C%87offer/"/>
      <url>/2023/07/30/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="剑指offer"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#剑指offer-1">字符串</button></li><li class="tab"><button type="button" data-href="#剑指offer-2">链表</button></li><li class="tab"><button type="button" data-href="#剑指offer-3">双指针</button></li><li class="tab"><button type="button" data-href="#剑指offer-4">栈与队列</button></li><li class="tab"><button type="button" data-href="#剑指offer-5">模拟</button></li><li class="tab"><button type="button" data-href="#剑指offer-6">查找算法</button></li><li class="tab"><button type="button" data-href="#剑指offer-7">搜索与回溯算法</button></li><li class="tab"><button type="button" data-href="#剑指offer-8">分治算法</button></li><li class="tab"><button type="button" data-href="#剑指offer-9">排序</button></li><li class="tab"><button type="button" data-href="#剑指offer-10">动态规划</button></li><li class="tab"><button type="button" data-href="#剑指offer-11">位运算</button></li><li class="tab"><button type="button" data-href="#剑指offer-12">数学</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="剑指offer-1"><h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/?envType=study-plan-v2&amp;envId=coding-interviews">剑指 Offer 05. 替换空格</a></h1><h2 id="方法1：原地修改"><a href="#方法1：原地修改" class="headerlink" title="方法1：原地修改"></a>方法1：原地修改</h2><h3 id="实现1：使用库函数replace"><a href="#实现1：使用库函数replace" class="headerlink" title="实现1：使用库函数replace"></a>实现1：使用库函数replace</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != <span class="number">-1</span>) s.<span class="built_in">replace</span>(s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>), <span class="number">1</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现2：双指针"><a href="#实现2：双指针" class="headerlink" title="实现2：双指针"></a>实现2：双指针</h3><ul><li>首先线性扫描统计愿串中的所有空格。记作count</li><li>然后增大原串的大小。</li><li>然后倒序进行遍历，i指针指向原串的最后一个位置，j指针指向s串扩充后的最后一个位置。如果当前遍历的s[i]串不为空格，则直接复制到相应的s[j]位置。否则需要将s[j - 2]、s[j - 1]、s[j]对应位置填充‘%’、‘2’、‘0’这3个字符，然后j -= 2.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, len = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line"></span><br><span class="line">        s.<span class="built_in">resize</span>(len + <span class="number">2</span> * count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[j] = s[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[j - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                s[j - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                j -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法2：直接遍历"><a href="#方法2：直接遍历" class="headerlink" title="方法2：直接遍历"></a>方法2：直接遍历</h2><blockquote><p>需要准备一个空间较大的答案字符串ans, 然后直接线性扫描s串的同时，判断当前的字符是否为空格，如果为空格的话，则需要连续地在答案字符中添加”%20”， 否则直接拷贝当前的字符</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) ans += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans += c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/?envType=study-plan-v2&amp;envId=coding-interviews">剑指 Offer 58 - II. 左旋转字符串</a></h1><h2 id="方法1：直接使用substr函数来拼接"><a href="#方法1：直接使用substr函数来拼接" class="headerlink" title="方法1：直接使用substr函数来拼接"></a>方法1：直接使用substr函数来拼接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(n) + s.<span class="built_in">substr</span>(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法2：两次遍历"><a href="#方法2：两次遍历" class="headerlink" title="方法2：两次遍历"></a>方法2：两次遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            ans += s[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            ans += s[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用求余优化成一次遍历<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt; n + s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            ans += s[i % s.<span class="built_in">size</span>()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法3：3次翻转"><a href="#方法3：3次翻转" class="headerlink" title="方法3：3次翻转"></a>方法3：3次翻转</h2><blockquote><p> eg：将abcdefg 按照n = 2得到最终的串cdefgab？<br>    设字符串长度为len</p><ol><li>整个字符串进行翻转：gfedcba</li><li>翻转前len - n个字符：cdefgba</li><li>翻转后n个字符：cdefgab</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - n, s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/?envType=study-plan-v2&amp;envId=coding-interviews">剑指 Offer 20. 表示数值的字符串</a></h1><h2 id="方法1：模拟-分类讨论"><a href="#方法1：模拟-分类讨论" class="headerlink" title="方法1：模拟+分类讨论"></a>方法1：模拟+分类讨论</h2><blockquote><p> 一个完整的加入可选项的最完整字符串如下：</p><ul><li>“(空格) (+/-) 小数/整数 (e/E) (+/-) (整数) (空格)”<ul><li>小数合法的3种形式<ul><li>“1.”(小数点有一位数，然后小数点)</li><li>“1.1”(小数点有一位数，然后小数点)</li><li>“.1”(一个小数点以及至少一位数)</li></ul></li><li>整数的合法形式<ul><li>6(至少一位数)<br>思路：可以先将对答案不造成影响的可选内容给去掉。比如空格。然后再对照合法字符串的字符顺序队输入串从左往右依次判断当前字符出现了某个特定字符，然后在此情况下，什么情况不合法，然后直接排除，如果再整个过程中都没有出现不合法的情况，则最后返回true.<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.去掉空格</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.如果存在正负号，则需要去掉，因为正负号是可选的！</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//排除正负符号后可能只有小数点&quot;.&quot;这时候是不合法的，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.剩下的部分就是&quot;小数/整数 (e/E) (+/-) (整数)&quot;</span></span><br><span class="line">        <span class="comment">//可能出现的字符有：&#x27;.&#x27;, &#x27;0&#x27;-&#x27;9&#x27;, &#x27;e/E&#x27;, &#x27;+/-&#x27;</span></span><br><span class="line">        <span class="type">int</span> e = <span class="number">0</span>, dot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//小数点可能优先出现(属于小数部分)</span></span><br><span class="line">                dot++;</span><br><span class="line">                <span class="comment">//小数点是在小数部分中需要的，并且只能有一个，如果出现大于或者等于</span></span><br><span class="line">                <span class="comment">//2次的情况，则不合法</span></span><br><span class="line">                <span class="comment">//小数点是在eE符号的前面，因此如果e已经出现了，则也不合法。</span></span><br><span class="line">                <span class="keyword">if</span> (dot &gt; <span class="number">1</span> || e) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                e++;</span><br><span class="line">                <span class="comment">//1).当&#x27;e&#x27;或&#x27;E&#x27;出现两次及以上时，则不合法</span></span><br><span class="line">                <span class="comment">//2).如果第一个字符就是&#x27;e/E&#x27;, 则不合法</span></span><br><span class="line">                <span class="comment">//3).如果最后一个字母是&#x27;E/e&#x27;, 则不合法</span></span><br><span class="line">                <span class="keyword">if</span> (e &gt; <span class="number">1</span> || (i == <span class="number">0</span>) || (i + <span class="number">1</span>) == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//4).当e出现在第1个位置，并且前一个位置为小数点时，则不合法</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//5).当e出现在倒数第2个位置，并且最后一个位置为正负号时，则不合法</span></span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i + <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//跳过正负号</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//出现了其他类型的字符，则直接不合法！！！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></blockquote><h2 id="方法2：利用FSM来解"><a href="#方法2：利用FSM来解" class="headerlink" title="方法2：利用FSM来解"></a>方法2：利用FSM来解</h2><h3 id="如果对FSM还很陌生，可以参考来加深理解FSM的简单编程应用"><a href="#如果对FSM还很陌生，可以参考来加深理解FSM的简单编程应用" class="headerlink" title="如果对FSM还很陌生，可以参考来加深理解FSM的简单编程应用"></a>如果对FSM还很陌生，可以参考来加深理解<a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solutions/2324990/cong-jian-dan-wen-ti-pan-duan-shi-fou-yo-o7kk/">FSM的简单编程应用</a></h3><blockquote><p> 一个完整的加入可选项的最完整字符串如下：</p><ul><li>“(空格) (+/-) 小数/整数 (e/E) (+/-) (整数) (空格)”</li><li>确定状态(从0开逐一表示状态)<br>0.开始的空格<br>1.正负号(给小数或者整数的)<br>2.小数前的数字<br>3.小数点及小数点后的数字(因为小数点后可以没有数字也合法)<br>4.当小数点前为空格时，小数点及小数点后的数字(没有2,3状态时的情况，实际跟2,3是并列的，有它没我，有我没它)<br>5.幂符号<br>6.给幂的正负符号<br>7.幂符号后的数字<br>8.结尾的空格</li><li>画状态转移图(此处参考K神的图)</li></ul></blockquote><p><img src="https://pic.leetcode.cn/1688051432-BIfolL-参考fsm判断字符串是否为合法数字.png" alt="参考fsm判断字符串是否为合法数字.png"></p><pre><code>- 由此可知当最后状态如果处在为2,3,7,8状态时，则说明是合法数字字符串。</code></pre><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pci;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据状态转移图初始化状态转移表</span></span><br><span class="line">        <span class="comment">//这里为啥这么定义可以参考上述提到FSM简单应用的编程例子</span></span><br><span class="line">        vector&lt;um&gt; state = &#123;</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>), <span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>), <span class="built_in">pci</span>(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>), <span class="built_in">pci</span>(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>), <span class="built_in">pci</span>(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>), <span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>), <span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>), <span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>)&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;<span class="comment">//初始状态</span></span><br><span class="line">        <span class="type">char</span> t;<span class="comment">//设置某一类字符结合的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">                t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">                t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                t = c;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state[st].<span class="built_in">count</span>(t) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            st = (<span class="type">int</span>)state[st][t];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> st == <span class="number">2</span> || st == <span class="number">3</span> || st == <span class="number">7</span> || st == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/?envType=study-plan-v2&amp;envId=coding-interviews">剑指 Offer 67. 把字符串转换成整数</a></h1><h2 id="方法1：模拟"><a href="#方法1：模拟" class="headerlink" title="方法1：模拟"></a>方法1：模拟</h2><blockquote><p>首先跳过空格，然后跳过正负符号，并且记录正负性，计算数值<br>的绝对值，最后确定正负，然后边界处理</p><ul><li>注意：INT_MAX：2147483647 , 因为不能超出2147483647，所以当ans计算的位数与最大值的位数差1时，当还有数字字符并且ans &gt; 214748364时这时直接根据符号返回最大值或者最小值(因为ans * 10 已经越界了)，当还有数字字符并且ans = 214748364时，这时需要考虑当前数字字符是否满足要求，如果已经大于最大值最后一位数字，则再ans的话也就溢出了，因此直接返回最大值或最小值。<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.去掉行首空格</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) i++; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.如果有符号就记录符号</span></span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>) i++, sign = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.如果出现了非数字，则直接退出，否则就累加数字</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//整数最大值2147483647 / 10 = 214748364</span></span><br><span class="line">        <span class="comment">//ans 不能超过214748364(x), 其中x&lt;=7</span></span><br><span class="line">        <span class="type">int</span> border = INT_MAX / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; border || ans == border &amp;&amp; str[i] &gt; <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">-1</span> ? INT_MIN : INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="方法2：FSM"><a href="#方法2：FSM" class="headerlink" title="方法2：FSM"></a>方法2：FSM</h2><blockquote><p>定义状态：程序每时每刻都有一个状态s, 每次从序列中输入一个字符c，并根据字符c转移到到下一个状态s’。因此，只需要建立一个覆盖所有情况的从s与c映射到s’ 的表格即可解决题目中的问题。</p><ul><li>处于空格的状态</li><li>处于符号的状态</li><li>处于数字的状态</li><li>返回状态</li></ul><p>画状态转移图<br><img src="https://pic.leetcode.cn/1688140756-DEOVEz-strtoint.png" alt="strtoint.png"><br><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solutions/2324990/cong-jian-dan-wen-ti-pan-duan-shi-fou-yo-o7kk/">FSM不好理解，可以从这个简单例子来加深对FSM的理解</a><br><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; um;</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pci;</span><br><span class="line">        vector&lt;um&gt; state = &#123;</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>), <span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>), <span class="built_in">pci</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>)&#125;, </span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>)&#125;,</span><br><span class="line">            um&#123;<span class="built_in">pci</span>(<span class="string">&#x27; &#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>), <span class="built_in">pci</span>(<span class="string">&#x27;o&#x27;</span>, <span class="number">3</span>)&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>, st = <span class="number">0</span>, ans = <span class="number">0</span>, border = INT_MAX / <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">                t = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">                t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">                t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            st = state[st][t];</span><br><span class="line">            <span class="keyword">if</span> (st == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans &gt; border || (ans == border &amp;&amp; c &gt; <span class="string">&#x27;7&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = ans * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st == <span class="number">1</span>) &#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (st == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Automaton &#123;</span><br><span class="line">    typedef unordered_map&lt;char, int&gt; um;</span><br><span class="line">    typedef pair&lt;char, int&gt; pci;</span><br><span class="line">    vector&lt;um&gt; state = &#123;</span><br><span class="line">        um&#123;pci(&#x27; &#x27;, 0), pci(&#x27;s&#x27;, 1), pci(&#x27;d&#x27;, 2), pci(&#x27;o&#x27;, 3)&#125;,</span><br><span class="line">        um&#123;pci(&#x27; &#x27;, 3), pci(&#x27;s&#x27;, 3), pci(&#x27;o&#x27;, 3), pci(&#x27;d&#x27;, 2)&#125;, </span><br><span class="line">        um&#123;pci(&#x27; &#x27;, 3), pci(&#x27;s&#x27;, 3), pci(&#x27;o&#x27;, 3), pci(&#x27;d&#x27;, 2)&#125;,</span><br><span class="line">        um&#123;pci(&#x27; &#x27;, 3), pci(&#x27;s&#x27;, 3), pci(&#x27;d&#x27;, 3), pci(&#x27;o&#x27;, 3)&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    char get_nst(char c) &#123;</span><br><span class="line">        if (c == &#x27; &#x27;) return &#x27; &#x27;;</span><br><span class="line">        if (c == &#x27;+&#x27; or c == &#x27;-&#x27;) return &#x27;s&#x27;;</span><br><span class="line">        if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return &#x27;d&#x27;;</span><br><span class="line">        else return &#x27;o&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int sign = 1, st = 0, ans = 0, border = INT_MAX / 10;</span><br><span class="line">    bool end = false;</span><br><span class="line">    void get(char c) &#123;</span><br><span class="line">        if (end == true) return;</span><br><span class="line">        st = state[st][get_nst(c)];</span><br><span class="line">        if (st == 2) &#123;</span><br><span class="line">            if (ans &gt; border || (ans == border &amp;&amp; c &gt; &#x27;7&#x27;)) &#123;</span><br><span class="line">                ans = (sign == 1) ? INT_MAX : INT_MIN;</span><br><span class="line">                end = true;</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans = ans * 10 + (c - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (st == 1) &#123;</span><br><span class="line">            sign = (c == &#x27;+&#x27;) ? 1 : -1;</span><br><span class="line">        &#125; else if (st == 3) &#123;</span><br><span class="line">            end = true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strToInt(string str) &#123;</span><br><span class="line">        Automaton automaton;</span><br><span class="line">        for (auto c : str) &#123;    </span><br><span class="line">            automaton.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (automaton.ans == INT_MIN) </span><br><span class="line">            return automaton.ans;</span><br><span class="line">        else return automaton.sign * automaton.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-2"><h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/?envType=study-plan-v2&amp;envId=coding-interviews">剑指 Offer 06. 从尾到头打印链表</a></h1><h2 id="方法1：递推（迭代）-分步"><a href="#方法1：递推（迭代）-分步" class="headerlink" title="方法1：递推（迭代）+分步"></a>方法1：递推（迭代）+分步</h2><ul><li>每遍历一个结点，就存储值到数组中</li><li>最后再翻转数组(可以直接stl库函数， 也可以使用双指针来实现自己实现翻转函数)<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法2：递归"><a href="#方法2：递归" class="headerlink" title="方法2：递归"></a>方法2：递归</h2><h3 id="实现1：分步"><a href="#实现1：分步" class="headerlink" title="实现1：分步"></a>实现1：分步</h3></li><li>每递归一层就记录当前的值到数组中</li><li>翻转数组<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(ListNode*)&gt; dfs = [&amp;](ListNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//先计算值</span></span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;next);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现2：一步到位，无需翻转"><a href="#实现2：一步到位，无需翻转" class="headerlink" title="实现2：一步到位，无需翻转"></a>实现2：一步到位，无需翻转</h3></li><li>注意：递结束，归开始才进行真正的操作：添加值到数组中(系统栈弹栈过程中)<figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(ListNode*)&gt; dfs = [&amp;](ListNode* node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;<span class="comment">//递结束条件</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span>(node-&gt;next);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//递结束后，归的过程中会执行该代码！！！</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法3：用栈模拟递归一步到位"><a href="#方法3：用栈模拟递归一步到位" class="headerlink" title="方法3：用栈模拟递归一步到位"></a>方法3：用栈模拟递归一步到位</h2><ul><li><strong>注意：递归本质在程序动态执行过程中就是系统栈来维护的</strong><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//压栈：对应递归的递</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹栈过程中，才真正的进行添加操作(对应递归的归)</span></span><br><span class="line">        <span class="keyword">while</span> (stk.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-5"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-6"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-7"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-8"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-9"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-10"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-11"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="剑指offer-12"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法学习</title>
      <link href="/2023/07/30/CPlusPlus%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/30/CPlusPlus%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语法学习"><a href="#C-语法学习" class="headerlink" title="C++语法学习"></a>C++语法学习</h1><h2 id="C-基础入门"><a href="#C-基础入门" class="headerlink" title="C++基础入门"></a>C++基础入门</h2><h3 id="1-C-初识"><a href="#1-C-初识" class="headerlink" title="1. C++初识"></a>1. C++初识</h3><h4 id="1-1-第一个c-c程序：输出hello-world"><a href="#1-1-第一个c-c程序：输出hello-world" class="headerlink" title="1.1 第一个c++c程序：输出hello world!!!"></a>1.1 第一个c++c程序：输出hello world!!!</h4><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h4><ul><li>单行注释：<code>//</code></li><li>多行注释：<code>/**/</code><h4 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h4></li><li>意义：给一段指定的内存空间取别名，方便操作这段内存</li><li>语法：<code>数据类型 变量名 初始值;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;在一个大小为<span class="number">4</span>字节的空间存储数字<span class="number">10</span>，这段空间的起始地址为a</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h4></li><li>作用：用于记录程序中不可更改的数据</li><li>C++定义常量方式：<ul><li><code>#define 宏常量：#define 常量名 常量值</code><ul><li>通常文件上方定义，表示一个常量</li></ul></li><li>const修饰的变量const数据类型 变量名 = 常量值<ul><li>通常在变量前加关键字const, 修饰该变量为常量，不可更改(告知编译器) </li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h4><ul><li>作用：关键字是C++预先保留的单词(标识符)</li><li><strong>在定义变量名或者常量名的时候，不要用关键字</strong></li></ul><div class="table-container"><table><thead><tr><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td></tr></tbody></table></div><p><code>提示：在给常量或者变量起名称时候，不要用C++关键字，否则会产生歧义。</code></p><h4 id="1-6-标识符命名规则"><a href="#1-6-标识符命名规则" class="headerlink" title="1.6 标识符命名规则"></a>1.6 标识符命名规则</h4><p><strong>作用</strong>: C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写<blockquote><p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p></blockquote></li></ul><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="type">int</span> = <span class="number">10</span>;<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span> <span class="number">1223</span>adb = <span class="number">40</span>;<span class="comment">//错误</span></span><br><span class="line">    <span class="type">int</span> aa = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; AA &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h4 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h4><p><strong>作用</strong>：整型变量表示的是整数类型的数据<br>C++中能够表示整形的类型有以下几种方式，<strong>区别在于</strong>所占内存空间不同：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15~2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31~2^31-1)</td></tr><tr><td>long(长整型)</td><td>Windows为4字节，Linux为子4字节(32位)，8字节(32位)</td><td>(-2^31~2^31-1)</td></tr><tr><td>long long(长长整型)</td><td>8字节</td><td>(-2^63~2^63-1)</td></tr></tbody></table></div><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> d = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">long</span> b = <span class="number">40</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;<span class="comment">//(-32768~32767) d = 32768, 输出为-32768</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-sizeof关键字"><a href="#2-2-sizeof关键字" class="headerlink" title="2.2 sizeof关键字"></a>2.2 sizeof关键字</h4><p><strong>作用</strong>：利用sizeof关键字可以统计数据类型所占空间大小<br><strong>语法</strong>：<code>sizeof(数据类型 / 变量)</code><br><strong>示例</strong>：<br><figure class="highlight c++"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> d = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">long</span> b = <span class="number">40</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(-32768~32767) d = 32768, 输出为-32768</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d占用空间内存= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a占用空间内存= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b占用空间内存= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c占用空间内存= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>总结：short &lt; int &lt;= long &lt;= long long</code></p><h4 id="2-3-实型-浮点型"><a href="#2-3-实型-浮点型" class="headerlink" title="2.3 实型(浮点型)"></a>2.3 实型(浮点型)</h4><p><strong>作用</strong>：用于表示小数</p><p>浮点型变量分为两种：</p><ol><li>单精度float</li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的数字范围不同。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>16-56位有效数字</td></tr></tbody></table></div><p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">3.1415925f</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">3.1415925</span><span class="comment">//编辑器默认把小数当成高精度，并且默认会显示6位有效数字</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float 占用空间：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double 占用空间：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//科学计数法</span></span><br><span class="line">    <span class="type">float</span> f2 = <span class="number">2e2</span>;<span class="comment">//3 * 10 ^ 2</span></span><br><span class="line">    cout &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> f3 = <span class="number">2e-2</span><span class="comment">//2 * 0.1 ^ 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h4><p><strong>作用</strong>：字符变量用于显示单个字符<br><strong>语法</strong>：`char ch = ‘a’;</p><blockquote><p>注意1：C和C++字符串变量中用于显示单个字符<br>注意2：单引号只能有一个字符，不可以是字符串</p></blockquote><ul><li>C和C++中字符串变量只占用一个字节</li><li>字符串变量并不是把字符放到内存中存储，而是将对应的ASCII编码放到存储单元中</li></ul><p><strong>示例</strong>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符型创建变量方式</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符型变量所占的内存大小</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符型变量常见的错误</span></span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;abs&#x27;</span>;<span class="comment">//错误，单引号中只能存放一个字符</span></span><br><span class="line">    <span class="type">char</span> ch2 = <span class="string">&quot;a&quot;</span>;<span class="comment">//错误，必须是单引号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符型变量的ASCII编码值</span></span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// a-97</span></span><br><span class="line">    <span class="comment">// A-65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ASCII可显示字符<br>可显示字符编号从32-126（0x20-0x7E）， 共95个字符<br><img src="https://www.runoob.com/wp-content/uploads/2022/03/ascii-1-1.png" alt="可显示字符"></p><p>控制字符<br>ASCII控制字符的编号范围是0-31和127（0x00-0x1F和0x7F），共33个字符<br><img src="https://www.runoob.com/wp-content/uploads/2022/03/ascii-2-1.png" alt="控制字符"></p><h4 id="2-5-转义字符"><a href="#2-5-转义字符" class="headerlink" title="2.5 转义字符"></a>2.5 转义字符</h4><p><strong>作用</strong>：用于表示一些不能显示出来的ASCII字符<br>现阶段我们常用的转移字符有：<code>\t \\ \n</code></p><div class="table-container"><table><thead><tr><th>转义字符</th><th>含义</th><th>有效数字范ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格（BS），将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移动到下页开头</td><td>012</td></tr><tr><td><strong>\n</strong></td><td><strong>换行（LF），将当前位置移动到下行开头</strong></td><td><strong>010</strong></td></tr><tr><td>\r</td><td>回车（CR），将当前位置移动到本行开头</td><td>013</td></tr><tr><td><strong>\t</strong></td><td><strong>水平制表（HT），跳到下一个tab位置</strong></td><td><strong>009</strong></td></tr><tr><td>\v</td><td>竖直制表（VT）</td><td>011</td></tr><tr><td>\ \</td><td><strong>代表一个反斜杠”\”</strong></td><td><strong>092</strong></td></tr><tr><td>\ ‘</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>\ “</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>\ ?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\ 0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>八进制转义字符，d范围0~7</td><td>3位八进制</td></tr><tr><td>\xhh</td><td>十六进制转义字符，范围0~9, a~f, A~F</td><td>3位十六进制</td></tr></tbody></table></div><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h2 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
